// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: robot/control.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_robot_2fcontrol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_robot_2fcontrol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_robot_2fcontrol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_robot_2fcontrol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_robot_2fcontrol_2eproto;
namespace robot {
namespace control {
class CapVelAndAccel;
struct CapVelAndAccelDefaultTypeInternal;
extern CapVelAndAccelDefaultTypeInternal _CapVelAndAccel_default_instance_;
class CoordinateControl;
struct CoordinateControlDefaultTypeInternal;
extern CoordinateControlDefaultTypeInternal _CoordinateControl_default_instance_;
class GlobalCoordinates;
struct GlobalCoordinatesDefaultTypeInternal;
extern GlobalCoordinatesDefaultTypeInternal _GlobalCoordinates_default_instance_;
class KickerAndDribbler;
struct KickerAndDribblerDefaultTypeInternal;
extern KickerAndDribblerDefaultTypeInternal _KickerAndDribbler_default_instance_;
class OldFormat;
struct OldFormatDefaultTypeInternal;
extern OldFormatDefaultTypeInternal _OldFormat_default_instance_;
class RobotCommand;
struct RobotCommandDefaultTypeInternal;
extern RobotCommandDefaultTypeInternal _RobotCommand_default_instance_;
class SpeedControl;
struct SpeedControlDefaultTypeInternal;
extern SpeedControlDefaultTypeInternal _SpeedControl_default_instance_;
class Target;
struct TargetDefaultTypeInternal;
extern TargetDefaultTypeInternal _Target_default_instance_;
}  // namespace control
}  // namespace robot
PROTOBUF_NAMESPACE_OPEN
template<> ::robot::control::CapVelAndAccel* Arena::CreateMaybeMessage<::robot::control::CapVelAndAccel>(Arena*);
template<> ::robot::control::CoordinateControl* Arena::CreateMaybeMessage<::robot::control::CoordinateControl>(Arena*);
template<> ::robot::control::GlobalCoordinates* Arena::CreateMaybeMessage<::robot::control::GlobalCoordinates>(Arena*);
template<> ::robot::control::KickerAndDribbler* Arena::CreateMaybeMessage<::robot::control::KickerAndDribbler>(Arena*);
template<> ::robot::control::OldFormat* Arena::CreateMaybeMessage<::robot::control::OldFormat>(Arena*);
template<> ::robot::control::RobotCommand* Arena::CreateMaybeMessage<::robot::control::RobotCommand>(Arena*);
template<> ::robot::control::SpeedControl* Arena::CreateMaybeMessage<::robot::control::SpeedControl>(Arena*);
template<> ::robot::control::Target* Arena::CreateMaybeMessage<::robot::control::Target>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace robot {
namespace control {

enum RobotControlType : int {
  OLD_FORMAT = 0,
  KICKER_AND_DRIBBLER = 1,
  SPEED_CONTROL = 2,
  COORDINATE_CONTROL = 3,
  GLOBAL_COORDINATES = 4,
  CAP_VEL_AND_ACCEL = 5
};
bool RobotControlType_IsValid(int value);
constexpr RobotControlType RobotControlType_MIN = OLD_FORMAT;
constexpr RobotControlType RobotControlType_MAX = CAP_VEL_AND_ACCEL;
constexpr int RobotControlType_ARRAYSIZE = RobotControlType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RobotControlType_descriptor();
template<typename T>
inline const std::string& RobotControlType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RobotControlType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RobotControlType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RobotControlType_descriptor(), enum_t_value);
}
inline bool RobotControlType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RobotControlType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RobotControlType>(
    RobotControlType_descriptor(), name, value);
}
enum KickerMode : int {
  IDLE = 0,
  KICK_STRAIGHT = 1,
  KICK_HIGH = 2,
  AUTOKICK_STRAIGHT = 3,
  AUTOKICK_HIGH = 4
};
bool KickerMode_IsValid(int value);
constexpr KickerMode KickerMode_MIN = IDLE;
constexpr KickerMode KickerMode_MAX = AUTOKICK_HIGH;
constexpr int KickerMode_ARRAYSIZE = KickerMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* KickerMode_descriptor();
template<typename T>
inline const std::string& KickerMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, KickerMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function KickerMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    KickerMode_descriptor(), enum_t_value);
}
inline bool KickerMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, KickerMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<KickerMode>(
    KickerMode_descriptor(), name, value);
}
// ===================================================================

class OldFormat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.control.OldFormat) */ {
 public:
  inline OldFormat() : OldFormat(nullptr) {}
  ~OldFormat() override;
  explicit PROTOBUF_CONSTEXPR OldFormat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OldFormat(const OldFormat& from);
  OldFormat(OldFormat&& from) noexcept
    : OldFormat() {
    *this = ::std::move(from);
  }

  inline OldFormat& operator=(const OldFormat& from) {
    CopyFrom(from);
    return *this;
  }
  inline OldFormat& operator=(OldFormat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OldFormat& default_instance() {
    return *internal_default_instance();
  }
  static inline const OldFormat* internal_default_instance() {
    return reinterpret_cast<const OldFormat*>(
               &_OldFormat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(OldFormat& a, OldFormat& b) {
    a.Swap(&b);
  }
  inline void Swap(OldFormat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OldFormat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OldFormat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OldFormat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OldFormat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OldFormat& from) {
    OldFormat::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OldFormat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.control.OldFormat";
  }
  protected:
  explicit OldFormat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVelXFieldNumber = 1,
    kVelYFieldNumber = 2,
    kAngularVelocityOrDeltaAngleFieldNumber = 3,
    kKickerSettingFieldNumber = 4,
    kDribblerSettingFieldNumber = 5,
    kAutokickStraightFieldNumber = 7,
    kAutokickHighFieldNumber = 8,
    kKickStraightFieldNumber = 9,
    kKickHighFieldNumber = 10,
    kAngvelAngleToggleFieldNumber = 11,
    kDribblerIsEnabledFieldNumber = 12,
    kHighVoltageFieldNumber = 13,
  };
  // required sint32 vel_x = 1;
  bool has_vel_x() const;
  private:
  bool _internal_has_vel_x() const;
  public:
  void clear_vel_x();
  int32_t vel_x() const;
  void set_vel_x(int32_t value);
  private:
  int32_t _internal_vel_x() const;
  void _internal_set_vel_x(int32_t value);
  public:

  // required sint32 vel_y = 2;
  bool has_vel_y() const;
  private:
  bool _internal_has_vel_y() const;
  public:
  void clear_vel_y();
  int32_t vel_y() const;
  void set_vel_y(int32_t value);
  private:
  int32_t _internal_vel_y() const;
  void _internal_set_vel_y(int32_t value);
  public:

  // required sint32 angular_velocity_or_delta_angle = 3;
  bool has_angular_velocity_or_delta_angle() const;
  private:
  bool _internal_has_angular_velocity_or_delta_angle() const;
  public:
  void clear_angular_velocity_or_delta_angle();
  int32_t angular_velocity_or_delta_angle() const;
  void set_angular_velocity_or_delta_angle(int32_t value);
  private:
  int32_t _internal_angular_velocity_or_delta_angle() const;
  void _internal_set_angular_velocity_or_delta_angle(int32_t value);
  public:

  // required uint32 kicker_setting = 4;
  bool has_kicker_setting() const;
  private:
  bool _internal_has_kicker_setting() const;
  public:
  void clear_kicker_setting();
  uint32_t kicker_setting() const;
  void set_kicker_setting(uint32_t value);
  private:
  uint32_t _internal_kicker_setting() const;
  void _internal_set_kicker_setting(uint32_t value);
  public:

  // required uint32 dribbler_setting = 5;
  bool has_dribbler_setting() const;
  private:
  bool _internal_has_dribbler_setting() const;
  public:
  void clear_dribbler_setting();
  uint32_t dribbler_setting() const;
  void set_dribbler_setting(uint32_t value);
  private:
  uint32_t _internal_dribbler_setting() const;
  void _internal_set_dribbler_setting(uint32_t value);
  public:

  // required bool autokick_straight = 7;
  bool has_autokick_straight() const;
  private:
  bool _internal_has_autokick_straight() const;
  public:
  void clear_autokick_straight();
  bool autokick_straight() const;
  void set_autokick_straight(bool value);
  private:
  bool _internal_autokick_straight() const;
  void _internal_set_autokick_straight(bool value);
  public:

  // required bool autokick_high = 8;
  bool has_autokick_high() const;
  private:
  bool _internal_has_autokick_high() const;
  public:
  void clear_autokick_high();
  bool autokick_high() const;
  void set_autokick_high(bool value);
  private:
  bool _internal_autokick_high() const;
  void _internal_set_autokick_high(bool value);
  public:

  // required bool kick_straight = 9;
  bool has_kick_straight() const;
  private:
  bool _internal_has_kick_straight() const;
  public:
  void clear_kick_straight();
  bool kick_straight() const;
  void set_kick_straight(bool value);
  private:
  bool _internal_kick_straight() const;
  void _internal_set_kick_straight(bool value);
  public:

  // required bool kick_high = 10;
  bool has_kick_high() const;
  private:
  bool _internal_has_kick_high() const;
  public:
  void clear_kick_high();
  bool kick_high() const;
  void set_kick_high(bool value);
  private:
  bool _internal_kick_high() const;
  void _internal_set_kick_high(bool value);
  public:

  // required bool angvel_angle_toggle = 11;
  bool has_angvel_angle_toggle() const;
  private:
  bool _internal_has_angvel_angle_toggle() const;
  public:
  void clear_angvel_angle_toggle();
  bool angvel_angle_toggle() const;
  void set_angvel_angle_toggle(bool value);
  private:
  bool _internal_angvel_angle_toggle() const;
  void _internal_set_angvel_angle_toggle(bool value);
  public:

  // required bool dribbler_is_enabled = 12;
  bool has_dribbler_is_enabled() const;
  private:
  bool _internal_has_dribbler_is_enabled() const;
  public:
  void clear_dribbler_is_enabled();
  bool dribbler_is_enabled() const;
  void set_dribbler_is_enabled(bool value);
  private:
  bool _internal_dribbler_is_enabled() const;
  void _internal_set_dribbler_is_enabled(bool value);
  public:

  // required bool high_voltage = 13;
  bool has_high_voltage() const;
  private:
  bool _internal_has_high_voltage() const;
  public:
  void clear_high_voltage();
  bool high_voltage() const;
  void set_high_voltage(bool value);
  private:
  bool _internal_high_voltage() const;
  void _internal_set_high_voltage(bool value);
  public:

  // @@protoc_insertion_point(class_scope:robot.control.OldFormat)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int32_t vel_x_;
    int32_t vel_y_;
    int32_t angular_velocity_or_delta_angle_;
    uint32_t kicker_setting_;
    uint32_t dribbler_setting_;
    bool autokick_straight_;
    bool autokick_high_;
    bool kick_straight_;
    bool kick_high_;
    bool angvel_angle_toggle_;
    bool dribbler_is_enabled_;
    bool high_voltage_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fcontrol_2eproto;
};
// -------------------------------------------------------------------

class KickerAndDribbler final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.control.KickerAndDribbler) */ {
 public:
  inline KickerAndDribbler() : KickerAndDribbler(nullptr) {}
  ~KickerAndDribbler() override;
  explicit PROTOBUF_CONSTEXPR KickerAndDribbler(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KickerAndDribbler(const KickerAndDribbler& from);
  KickerAndDribbler(KickerAndDribbler&& from) noexcept
    : KickerAndDribbler() {
    *this = ::std::move(from);
  }

  inline KickerAndDribbler& operator=(const KickerAndDribbler& from) {
    CopyFrom(from);
    return *this;
  }
  inline KickerAndDribbler& operator=(KickerAndDribbler&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KickerAndDribbler& default_instance() {
    return *internal_default_instance();
  }
  static inline const KickerAndDribbler* internal_default_instance() {
    return reinterpret_cast<const KickerAndDribbler*>(
               &_KickerAndDribbler_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(KickerAndDribbler& a, KickerAndDribbler& b) {
    a.Swap(&b);
  }
  inline void Swap(KickerAndDribbler* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KickerAndDribbler* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KickerAndDribbler* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KickerAndDribbler>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KickerAndDribbler& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KickerAndDribbler& from) {
    KickerAndDribbler::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KickerAndDribbler* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.control.KickerAndDribbler";
  }
  protected:
  explicit KickerAndDribbler(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKickerModeFieldNumber = 1,
    kKickerSettingFieldNumber = 2,
    kDribblerSettingFieldNumber = 3,
  };
  // required .robot.control.KickerMode kicker_mode = 1;
  bool has_kicker_mode() const;
  private:
  bool _internal_has_kicker_mode() const;
  public:
  void clear_kicker_mode();
  ::robot::control::KickerMode kicker_mode() const;
  void set_kicker_mode(::robot::control::KickerMode value);
  private:
  ::robot::control::KickerMode _internal_kicker_mode() const;
  void _internal_set_kicker_mode(::robot::control::KickerMode value);
  public:

  // required uint32 kicker_setting = 2;
  bool has_kicker_setting() const;
  private:
  bool _internal_has_kicker_setting() const;
  public:
  void clear_kicker_setting();
  uint32_t kicker_setting() const;
  void set_kicker_setting(uint32_t value);
  private:
  uint32_t _internal_kicker_setting() const;
  void _internal_set_kicker_setting(uint32_t value);
  public:

  // required uint32 dribbler_setting = 3;
  bool has_dribbler_setting() const;
  private:
  bool _internal_has_dribbler_setting() const;
  public:
  void clear_dribbler_setting();
  uint32_t dribbler_setting() const;
  void set_dribbler_setting(uint32_t value);
  private:
  uint32_t _internal_dribbler_setting() const;
  void _internal_set_dribbler_setting(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:robot.control.KickerAndDribbler)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    int kicker_mode_;
    uint32_t kicker_setting_;
    uint32_t dribbler_setting_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fcontrol_2eproto;
};
// -------------------------------------------------------------------

class SpeedControl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.control.SpeedControl) */ {
 public:
  inline SpeedControl() : SpeedControl(nullptr) {}
  ~SpeedControl() override;
  explicit PROTOBUF_CONSTEXPR SpeedControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SpeedControl(const SpeedControl& from);
  SpeedControl(SpeedControl&& from) noexcept
    : SpeedControl() {
    *this = ::std::move(from);
  }

  inline SpeedControl& operator=(const SpeedControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline SpeedControl& operator=(SpeedControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SpeedControl& default_instance() {
    return *internal_default_instance();
  }
  enum AngularVelocityOrAngleCase {
    kAngularVelocity = 3,
    kDeltaAngle = 4,
    ANGULAR_VELOCITY_OR_ANGLE_NOT_SET = 0,
  };

  static inline const SpeedControl* internal_default_instance() {
    return reinterpret_cast<const SpeedControl*>(
               &_SpeedControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SpeedControl& a, SpeedControl& b) {
    a.Swap(&b);
  }
  inline void Swap(SpeedControl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SpeedControl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SpeedControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SpeedControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SpeedControl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SpeedControl& from) {
    SpeedControl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SpeedControl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.control.SpeedControl";
  }
  protected:
  explicit SpeedControl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVelXFieldNumber = 1,
    kVelYFieldNumber = 2,
    kAngularVelocityFieldNumber = 3,
    kDeltaAngleFieldNumber = 4,
  };
  // required float vel_x = 1;
  bool has_vel_x() const;
  private:
  bool _internal_has_vel_x() const;
  public:
  void clear_vel_x();
  float vel_x() const;
  void set_vel_x(float value);
  private:
  float _internal_vel_x() const;
  void _internal_set_vel_x(float value);
  public:

  // required float vel_y = 2;
  bool has_vel_y() const;
  private:
  bool _internal_has_vel_y() const;
  public:
  void clear_vel_y();
  float vel_y() const;
  void set_vel_y(float value);
  private:
  float _internal_vel_y() const;
  void _internal_set_vel_y(float value);
  public:

  // float angular_velocity = 3;
  bool has_angular_velocity() const;
  private:
  bool _internal_has_angular_velocity() const;
  public:
  void clear_angular_velocity();
  float angular_velocity() const;
  void set_angular_velocity(float value);
  private:
  float _internal_angular_velocity() const;
  void _internal_set_angular_velocity(float value);
  public:

  // float delta_angle = 4;
  bool has_delta_angle() const;
  private:
  bool _internal_has_delta_angle() const;
  public:
  void clear_delta_angle();
  float delta_angle() const;
  void set_delta_angle(float value);
  private:
  float _internal_delta_angle() const;
  void _internal_set_delta_angle(float value);
  public:

  void clear_angular_velocity_or_angle();
  AngularVelocityOrAngleCase angular_velocity_or_angle_case() const;
  // @@protoc_insertion_point(class_scope:robot.control.SpeedControl)
 private:
  class _Internal;
  void set_has_angular_velocity();
  void set_has_delta_angle();

  inline bool has_angular_velocity_or_angle() const;
  inline void clear_has_angular_velocity_or_angle();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float vel_x_;
    float vel_y_;
    union AngularVelocityOrAngleUnion {
      constexpr AngularVelocityOrAngleUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      float angular_velocity_;
      float delta_angle_;
    } angular_velocity_or_angle_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fcontrol_2eproto;
};
// -------------------------------------------------------------------

class Target final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.control.Target) */ {
 public:
  inline Target() : Target(nullptr) {}
  ~Target() override;
  explicit PROTOBUF_CONSTEXPR Target(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Target(const Target& from);
  Target(Target&& from) noexcept
    : Target() {
    *this = ::std::move(from);
  }

  inline Target& operator=(const Target& from) {
    CopyFrom(from);
    return *this;
  }
  inline Target& operator=(Target&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Target& default_instance() {
    return *internal_default_instance();
  }
  static inline const Target* internal_default_instance() {
    return reinterpret_cast<const Target*>(
               &_Target_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Target& a, Target& b) {
    a.Swap(&b);
  }
  inline void Swap(Target* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Target* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Target* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Target>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Target& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Target& from) {
    Target::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Target* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.control.Target";
  }
  protected:
  explicit Target(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kXFieldNumber = 2,
    kYFieldNumber = 3,
    kVxFieldNumber = 4,
    kVyFieldNumber = 5,
    kAngleFieldNumber = 6,
  };
  // required uint32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // required float x = 2;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // required float y = 3;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // required float vx = 4;
  bool has_vx() const;
  private:
  bool _internal_has_vx() const;
  public:
  void clear_vx();
  float vx() const;
  void set_vx(float value);
  private:
  float _internal_vx() const;
  void _internal_set_vx(float value);
  public:

  // required float vy = 5;
  bool has_vy() const;
  private:
  bool _internal_has_vy() const;
  public:
  void clear_vy();
  float vy() const;
  void set_vy(float value);
  private:
  float _internal_vy() const;
  void _internal_set_vy(float value);
  public:

  // required float angle = 6;
  bool has_angle() const;
  private:
  bool _internal_has_angle() const;
  public:
  void clear_angle();
  float angle() const;
  void set_angle(float value);
  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);
  public:

  // @@protoc_insertion_point(class_scope:robot.control.Target)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t id_;
    float x_;
    float y_;
    float vx_;
    float vy_;
    float angle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fcontrol_2eproto;
};
// -------------------------------------------------------------------

class CoordinateControl final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.control.CoordinateControl) */ {
 public:
  inline CoordinateControl() : CoordinateControl(nullptr) {}
  ~CoordinateControl() override;
  explicit PROTOBUF_CONSTEXPR CoordinateControl(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CoordinateControl(const CoordinateControl& from);
  CoordinateControl(CoordinateControl&& from) noexcept
    : CoordinateControl() {
    *this = ::std::move(from);
  }

  inline CoordinateControl& operator=(const CoordinateControl& from) {
    CopyFrom(from);
    return *this;
  }
  inline CoordinateControl& operator=(CoordinateControl&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CoordinateControl& default_instance() {
    return *internal_default_instance();
  }
  static inline const CoordinateControl* internal_default_instance() {
    return reinterpret_cast<const CoordinateControl*>(
               &_CoordinateControl_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CoordinateControl& a, CoordinateControl& b) {
    a.Swap(&b);
  }
  inline void Swap(CoordinateControl* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CoordinateControl* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CoordinateControl* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CoordinateControl>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CoordinateControl& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CoordinateControl& from) {
    CoordinateControl::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoordinateControl* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.control.CoordinateControl";
  }
  protected:
  explicit CoordinateControl(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTargetsFieldNumber = 1,
  };
  // repeated .robot.control.Target targets = 1;
  int targets_size() const;
  private:
  int _internal_targets_size() const;
  public:
  void clear_targets();
  ::robot::control::Target* mutable_targets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::control::Target >*
      mutable_targets();
  private:
  const ::robot::control::Target& _internal_targets(int index) const;
  ::robot::control::Target* _internal_add_targets();
  public:
  const ::robot::control::Target& targets(int index) const;
  ::robot::control::Target* add_targets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::control::Target >&
      targets() const;

  // @@protoc_insertion_point(class_scope:robot.control.CoordinateControl)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::control::Target > targets_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fcontrol_2eproto;
};
// -------------------------------------------------------------------

class GlobalCoordinates final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.control.GlobalCoordinates) */ {
 public:
  inline GlobalCoordinates() : GlobalCoordinates(nullptr) {}
  ~GlobalCoordinates() override;
  explicit PROTOBUF_CONSTEXPR GlobalCoordinates(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GlobalCoordinates(const GlobalCoordinates& from);
  GlobalCoordinates(GlobalCoordinates&& from) noexcept
    : GlobalCoordinates() {
    *this = ::std::move(from);
  }

  inline GlobalCoordinates& operator=(const GlobalCoordinates& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalCoordinates& operator=(GlobalCoordinates&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GlobalCoordinates& default_instance() {
    return *internal_default_instance();
  }
  static inline const GlobalCoordinates* internal_default_instance() {
    return reinterpret_cast<const GlobalCoordinates*>(
               &_GlobalCoordinates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GlobalCoordinates& a, GlobalCoordinates& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalCoordinates* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalCoordinates* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GlobalCoordinates* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GlobalCoordinates>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GlobalCoordinates& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GlobalCoordinates& from) {
    GlobalCoordinates::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalCoordinates* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.control.GlobalCoordinates";
  }
  protected:
  explicit GlobalCoordinates(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kAngleFieldNumber = 3,
  };
  // required float x = 1;
  bool has_x() const;
  private:
  bool _internal_has_x() const;
  public:
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // required float y = 2;
  bool has_y() const;
  private:
  bool _internal_has_y() const;
  public:
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // required float angle = 3;
  bool has_angle() const;
  private:
  bool _internal_has_angle() const;
  public:
  void clear_angle();
  float angle() const;
  void set_angle(float value);
  private:
  float _internal_angle() const;
  void _internal_set_angle(float value);
  public:

  // @@protoc_insertion_point(class_scope:robot.control.GlobalCoordinates)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float x_;
    float y_;
    float angle_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fcontrol_2eproto;
};
// -------------------------------------------------------------------

class CapVelAndAccel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.control.CapVelAndAccel) */ {
 public:
  inline CapVelAndAccel() : CapVelAndAccel(nullptr) {}
  ~CapVelAndAccel() override;
  explicit PROTOBUF_CONSTEXPR CapVelAndAccel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CapVelAndAccel(const CapVelAndAccel& from);
  CapVelAndAccel(CapVelAndAccel&& from) noexcept
    : CapVelAndAccel() {
    *this = ::std::move(from);
  }

  inline CapVelAndAccel& operator=(const CapVelAndAccel& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapVelAndAccel& operator=(CapVelAndAccel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CapVelAndAccel& default_instance() {
    return *internal_default_instance();
  }
  static inline const CapVelAndAccel* internal_default_instance() {
    return reinterpret_cast<const CapVelAndAccel*>(
               &_CapVelAndAccel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CapVelAndAccel& a, CapVelAndAccel& b) {
    a.Swap(&b);
  }
  inline void Swap(CapVelAndAccel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapVelAndAccel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CapVelAndAccel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CapVelAndAccel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CapVelAndAccel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CapVelAndAccel& from) {
    CapVelAndAccel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CapVelAndAccel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.control.CapVelAndAccel";
  }
  protected:
  explicit CapVelAndAccel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaxVelFieldNumber = 1,
    kMaxAccelFieldNumber = 2,
  };
  // required float max_vel = 1;
  bool has_max_vel() const;
  private:
  bool _internal_has_max_vel() const;
  public:
  void clear_max_vel();
  float max_vel() const;
  void set_max_vel(float value);
  private:
  float _internal_max_vel() const;
  void _internal_set_max_vel(float value);
  public:

  // required float max_accel = 2;
  bool has_max_accel() const;
  private:
  bool _internal_has_max_accel() const;
  public:
  void clear_max_accel();
  float max_accel() const;
  void set_max_accel(float value);
  private:
  float _internal_max_accel() const;
  void _internal_set_max_accel(float value);
  public:

  // @@protoc_insertion_point(class_scope:robot.control.CapVelAndAccel)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    float max_vel_;
    float max_accel_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fcontrol_2eproto;
};
// -------------------------------------------------------------------

class RobotCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:robot.control.RobotCommand) */ {
 public:
  inline RobotCommand() : RobotCommand(nullptr) {}
  ~RobotCommand() override;
  explicit PROTOBUF_CONSTEXPR RobotCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotCommand(const RobotCommand& from);
  RobotCommand(RobotCommand&& from) noexcept
    : RobotCommand() {
    *this = ::std::move(from);
  }

  inline RobotCommand& operator=(const RobotCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotCommand& operator=(RobotCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotCommand& default_instance() {
    return *internal_default_instance();
  }
  enum ControlCase {
    kOldFormat = 2,
    kKickerAndDribbler = 3,
    kSpeedControl = 4,
    kCoordinateControl = 5,
    kGlobalCoordinates = 6,
    kCapVelAndAccel = 7,
    CONTROL_NOT_SET = 0,
  };

  static inline const RobotCommand* internal_default_instance() {
    return reinterpret_cast<const RobotCommand*>(
               &_RobotCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RobotCommand& a, RobotCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RobotCommand& from) {
    RobotCommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "robot.control.RobotCommand";
  }
  protected:
  explicit RobotCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotIdFieldNumber = 1,
    kOldFormatFieldNumber = 2,
    kKickerAndDribblerFieldNumber = 3,
    kSpeedControlFieldNumber = 4,
    kCoordinateControlFieldNumber = 5,
    kGlobalCoordinatesFieldNumber = 6,
    kCapVelAndAccelFieldNumber = 7,
  };
  // required uint32 robot_id = 1;
  bool has_robot_id() const;
  private:
  bool _internal_has_robot_id() const;
  public:
  void clear_robot_id();
  uint32_t robot_id() const;
  void set_robot_id(uint32_t value);
  private:
  uint32_t _internal_robot_id() const;
  void _internal_set_robot_id(uint32_t value);
  public:

  // .robot.control.OldFormat old_format = 2;
  bool has_old_format() const;
  private:
  bool _internal_has_old_format() const;
  public:
  void clear_old_format();
  const ::robot::control::OldFormat& old_format() const;
  PROTOBUF_NODISCARD ::robot::control::OldFormat* release_old_format();
  ::robot::control::OldFormat* mutable_old_format();
  void set_allocated_old_format(::robot::control::OldFormat* old_format);
  private:
  const ::robot::control::OldFormat& _internal_old_format() const;
  ::robot::control::OldFormat* _internal_mutable_old_format();
  public:
  void unsafe_arena_set_allocated_old_format(
      ::robot::control::OldFormat* old_format);
  ::robot::control::OldFormat* unsafe_arena_release_old_format();

  // .robot.control.KickerAndDribbler kicker_and_dribbler = 3;
  bool has_kicker_and_dribbler() const;
  private:
  bool _internal_has_kicker_and_dribbler() const;
  public:
  void clear_kicker_and_dribbler();
  const ::robot::control::KickerAndDribbler& kicker_and_dribbler() const;
  PROTOBUF_NODISCARD ::robot::control::KickerAndDribbler* release_kicker_and_dribbler();
  ::robot::control::KickerAndDribbler* mutable_kicker_and_dribbler();
  void set_allocated_kicker_and_dribbler(::robot::control::KickerAndDribbler* kicker_and_dribbler);
  private:
  const ::robot::control::KickerAndDribbler& _internal_kicker_and_dribbler() const;
  ::robot::control::KickerAndDribbler* _internal_mutable_kicker_and_dribbler();
  public:
  void unsafe_arena_set_allocated_kicker_and_dribbler(
      ::robot::control::KickerAndDribbler* kicker_and_dribbler);
  ::robot::control::KickerAndDribbler* unsafe_arena_release_kicker_and_dribbler();

  // .robot.control.SpeedControl speed_control = 4;
  bool has_speed_control() const;
  private:
  bool _internal_has_speed_control() const;
  public:
  void clear_speed_control();
  const ::robot::control::SpeedControl& speed_control() const;
  PROTOBUF_NODISCARD ::robot::control::SpeedControl* release_speed_control();
  ::robot::control::SpeedControl* mutable_speed_control();
  void set_allocated_speed_control(::robot::control::SpeedControl* speed_control);
  private:
  const ::robot::control::SpeedControl& _internal_speed_control() const;
  ::robot::control::SpeedControl* _internal_mutable_speed_control();
  public:
  void unsafe_arena_set_allocated_speed_control(
      ::robot::control::SpeedControl* speed_control);
  ::robot::control::SpeedControl* unsafe_arena_release_speed_control();

  // .robot.control.CoordinateControl coordinate_control = 5;
  bool has_coordinate_control() const;
  private:
  bool _internal_has_coordinate_control() const;
  public:
  void clear_coordinate_control();
  const ::robot::control::CoordinateControl& coordinate_control() const;
  PROTOBUF_NODISCARD ::robot::control::CoordinateControl* release_coordinate_control();
  ::robot::control::CoordinateControl* mutable_coordinate_control();
  void set_allocated_coordinate_control(::robot::control::CoordinateControl* coordinate_control);
  private:
  const ::robot::control::CoordinateControl& _internal_coordinate_control() const;
  ::robot::control::CoordinateControl* _internal_mutable_coordinate_control();
  public:
  void unsafe_arena_set_allocated_coordinate_control(
      ::robot::control::CoordinateControl* coordinate_control);
  ::robot::control::CoordinateControl* unsafe_arena_release_coordinate_control();

  // .robot.control.GlobalCoordinates global_coordinates = 6;
  bool has_global_coordinates() const;
  private:
  bool _internal_has_global_coordinates() const;
  public:
  void clear_global_coordinates();
  const ::robot::control::GlobalCoordinates& global_coordinates() const;
  PROTOBUF_NODISCARD ::robot::control::GlobalCoordinates* release_global_coordinates();
  ::robot::control::GlobalCoordinates* mutable_global_coordinates();
  void set_allocated_global_coordinates(::robot::control::GlobalCoordinates* global_coordinates);
  private:
  const ::robot::control::GlobalCoordinates& _internal_global_coordinates() const;
  ::robot::control::GlobalCoordinates* _internal_mutable_global_coordinates();
  public:
  void unsafe_arena_set_allocated_global_coordinates(
      ::robot::control::GlobalCoordinates* global_coordinates);
  ::robot::control::GlobalCoordinates* unsafe_arena_release_global_coordinates();

  // .robot.control.CapVelAndAccel cap_vel_and_accel = 7;
  bool has_cap_vel_and_accel() const;
  private:
  bool _internal_has_cap_vel_and_accel() const;
  public:
  void clear_cap_vel_and_accel();
  const ::robot::control::CapVelAndAccel& cap_vel_and_accel() const;
  PROTOBUF_NODISCARD ::robot::control::CapVelAndAccel* release_cap_vel_and_accel();
  ::robot::control::CapVelAndAccel* mutable_cap_vel_and_accel();
  void set_allocated_cap_vel_and_accel(::robot::control::CapVelAndAccel* cap_vel_and_accel);
  private:
  const ::robot::control::CapVelAndAccel& _internal_cap_vel_and_accel() const;
  ::robot::control::CapVelAndAccel* _internal_mutable_cap_vel_and_accel();
  public:
  void unsafe_arena_set_allocated_cap_vel_and_accel(
      ::robot::control::CapVelAndAccel* cap_vel_and_accel);
  ::robot::control::CapVelAndAccel* unsafe_arena_release_cap_vel_and_accel();

  void clear_control();
  ControlCase control_case() const;
  // @@protoc_insertion_point(class_scope:robot.control.RobotCommand)
 private:
  class _Internal;
  void set_has_old_format();
  void set_has_kicker_and_dribbler();
  void set_has_speed_control();
  void set_has_coordinate_control();
  void set_has_global_coordinates();
  void set_has_cap_vel_and_accel();

  inline bool has_control() const;
  inline void clear_has_control();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t robot_id_;
    union ControlUnion {
      constexpr ControlUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::robot::control::OldFormat* old_format_;
      ::robot::control::KickerAndDribbler* kicker_and_dribbler_;
      ::robot::control::SpeedControl* speed_control_;
      ::robot::control::CoordinateControl* coordinate_control_;
      ::robot::control::GlobalCoordinates* global_coordinates_;
      ::robot::control::CapVelAndAccel* cap_vel_and_accel_;
    } control_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_robot_2fcontrol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// OldFormat

// required sint32 vel_x = 1;
inline bool OldFormat::_internal_has_vel_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool OldFormat::has_vel_x() const {
  return _internal_has_vel_x();
}
inline void OldFormat::clear_vel_x() {
  _impl_.vel_x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline int32_t OldFormat::_internal_vel_x() const {
  return _impl_.vel_x_;
}
inline int32_t OldFormat::vel_x() const {
  // @@protoc_insertion_point(field_get:robot.control.OldFormat.vel_x)
  return _internal_vel_x();
}
inline void OldFormat::_internal_set_vel_x(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vel_x_ = value;
}
inline void OldFormat::set_vel_x(int32_t value) {
  _internal_set_vel_x(value);
  // @@protoc_insertion_point(field_set:robot.control.OldFormat.vel_x)
}

// required sint32 vel_y = 2;
inline bool OldFormat::_internal_has_vel_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool OldFormat::has_vel_y() const {
  return _internal_has_vel_y();
}
inline void OldFormat::clear_vel_y() {
  _impl_.vel_y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t OldFormat::_internal_vel_y() const {
  return _impl_.vel_y_;
}
inline int32_t OldFormat::vel_y() const {
  // @@protoc_insertion_point(field_get:robot.control.OldFormat.vel_y)
  return _internal_vel_y();
}
inline void OldFormat::_internal_set_vel_y(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.vel_y_ = value;
}
inline void OldFormat::set_vel_y(int32_t value) {
  _internal_set_vel_y(value);
  // @@protoc_insertion_point(field_set:robot.control.OldFormat.vel_y)
}

// required sint32 angular_velocity_or_delta_angle = 3;
inline bool OldFormat::_internal_has_angular_velocity_or_delta_angle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool OldFormat::has_angular_velocity_or_delta_angle() const {
  return _internal_has_angular_velocity_or_delta_angle();
}
inline void OldFormat::clear_angular_velocity_or_delta_angle() {
  _impl_.angular_velocity_or_delta_angle_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int32_t OldFormat::_internal_angular_velocity_or_delta_angle() const {
  return _impl_.angular_velocity_or_delta_angle_;
}
inline int32_t OldFormat::angular_velocity_or_delta_angle() const {
  // @@protoc_insertion_point(field_get:robot.control.OldFormat.angular_velocity_or_delta_angle)
  return _internal_angular_velocity_or_delta_angle();
}
inline void OldFormat::_internal_set_angular_velocity_or_delta_angle(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.angular_velocity_or_delta_angle_ = value;
}
inline void OldFormat::set_angular_velocity_or_delta_angle(int32_t value) {
  _internal_set_angular_velocity_or_delta_angle(value);
  // @@protoc_insertion_point(field_set:robot.control.OldFormat.angular_velocity_or_delta_angle)
}

// required uint32 kicker_setting = 4;
inline bool OldFormat::_internal_has_kicker_setting() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool OldFormat::has_kicker_setting() const {
  return _internal_has_kicker_setting();
}
inline void OldFormat::clear_kicker_setting() {
  _impl_.kicker_setting_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline uint32_t OldFormat::_internal_kicker_setting() const {
  return _impl_.kicker_setting_;
}
inline uint32_t OldFormat::kicker_setting() const {
  // @@protoc_insertion_point(field_get:robot.control.OldFormat.kicker_setting)
  return _internal_kicker_setting();
}
inline void OldFormat::_internal_set_kicker_setting(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.kicker_setting_ = value;
}
inline void OldFormat::set_kicker_setting(uint32_t value) {
  _internal_set_kicker_setting(value);
  // @@protoc_insertion_point(field_set:robot.control.OldFormat.kicker_setting)
}

// required uint32 dribbler_setting = 5;
inline bool OldFormat::_internal_has_dribbler_setting() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool OldFormat::has_dribbler_setting() const {
  return _internal_has_dribbler_setting();
}
inline void OldFormat::clear_dribbler_setting() {
  _impl_.dribbler_setting_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline uint32_t OldFormat::_internal_dribbler_setting() const {
  return _impl_.dribbler_setting_;
}
inline uint32_t OldFormat::dribbler_setting() const {
  // @@protoc_insertion_point(field_get:robot.control.OldFormat.dribbler_setting)
  return _internal_dribbler_setting();
}
inline void OldFormat::_internal_set_dribbler_setting(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.dribbler_setting_ = value;
}
inline void OldFormat::set_dribbler_setting(uint32_t value) {
  _internal_set_dribbler_setting(value);
  // @@protoc_insertion_point(field_set:robot.control.OldFormat.dribbler_setting)
}

// required bool autokick_straight = 7;
inline bool OldFormat::_internal_has_autokick_straight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool OldFormat::has_autokick_straight() const {
  return _internal_has_autokick_straight();
}
inline void OldFormat::clear_autokick_straight() {
  _impl_.autokick_straight_ = false;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline bool OldFormat::_internal_autokick_straight() const {
  return _impl_.autokick_straight_;
}
inline bool OldFormat::autokick_straight() const {
  // @@protoc_insertion_point(field_get:robot.control.OldFormat.autokick_straight)
  return _internal_autokick_straight();
}
inline void OldFormat::_internal_set_autokick_straight(bool value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.autokick_straight_ = value;
}
inline void OldFormat::set_autokick_straight(bool value) {
  _internal_set_autokick_straight(value);
  // @@protoc_insertion_point(field_set:robot.control.OldFormat.autokick_straight)
}

// required bool autokick_high = 8;
inline bool OldFormat::_internal_has_autokick_high() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool OldFormat::has_autokick_high() const {
  return _internal_has_autokick_high();
}
inline void OldFormat::clear_autokick_high() {
  _impl_.autokick_high_ = false;
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline bool OldFormat::_internal_autokick_high() const {
  return _impl_.autokick_high_;
}
inline bool OldFormat::autokick_high() const {
  // @@protoc_insertion_point(field_get:robot.control.OldFormat.autokick_high)
  return _internal_autokick_high();
}
inline void OldFormat::_internal_set_autokick_high(bool value) {
  _impl_._has_bits_[0] |= 0x00000040u;
  _impl_.autokick_high_ = value;
}
inline void OldFormat::set_autokick_high(bool value) {
  _internal_set_autokick_high(value);
  // @@protoc_insertion_point(field_set:robot.control.OldFormat.autokick_high)
}

// required bool kick_straight = 9;
inline bool OldFormat::_internal_has_kick_straight() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool OldFormat::has_kick_straight() const {
  return _internal_has_kick_straight();
}
inline void OldFormat::clear_kick_straight() {
  _impl_.kick_straight_ = false;
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline bool OldFormat::_internal_kick_straight() const {
  return _impl_.kick_straight_;
}
inline bool OldFormat::kick_straight() const {
  // @@protoc_insertion_point(field_get:robot.control.OldFormat.kick_straight)
  return _internal_kick_straight();
}
inline void OldFormat::_internal_set_kick_straight(bool value) {
  _impl_._has_bits_[0] |= 0x00000080u;
  _impl_.kick_straight_ = value;
}
inline void OldFormat::set_kick_straight(bool value) {
  _internal_set_kick_straight(value);
  // @@protoc_insertion_point(field_set:robot.control.OldFormat.kick_straight)
}

// required bool kick_high = 10;
inline bool OldFormat::_internal_has_kick_high() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool OldFormat::has_kick_high() const {
  return _internal_has_kick_high();
}
inline void OldFormat::clear_kick_high() {
  _impl_.kick_high_ = false;
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline bool OldFormat::_internal_kick_high() const {
  return _impl_.kick_high_;
}
inline bool OldFormat::kick_high() const {
  // @@protoc_insertion_point(field_get:robot.control.OldFormat.kick_high)
  return _internal_kick_high();
}
inline void OldFormat::_internal_set_kick_high(bool value) {
  _impl_._has_bits_[0] |= 0x00000100u;
  _impl_.kick_high_ = value;
}
inline void OldFormat::set_kick_high(bool value) {
  _internal_set_kick_high(value);
  // @@protoc_insertion_point(field_set:robot.control.OldFormat.kick_high)
}

// required bool angvel_angle_toggle = 11;
inline bool OldFormat::_internal_has_angvel_angle_toggle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool OldFormat::has_angvel_angle_toggle() const {
  return _internal_has_angvel_angle_toggle();
}
inline void OldFormat::clear_angvel_angle_toggle() {
  _impl_.angvel_angle_toggle_ = false;
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline bool OldFormat::_internal_angvel_angle_toggle() const {
  return _impl_.angvel_angle_toggle_;
}
inline bool OldFormat::angvel_angle_toggle() const {
  // @@protoc_insertion_point(field_get:robot.control.OldFormat.angvel_angle_toggle)
  return _internal_angvel_angle_toggle();
}
inline void OldFormat::_internal_set_angvel_angle_toggle(bool value) {
  _impl_._has_bits_[0] |= 0x00000200u;
  _impl_.angvel_angle_toggle_ = value;
}
inline void OldFormat::set_angvel_angle_toggle(bool value) {
  _internal_set_angvel_angle_toggle(value);
  // @@protoc_insertion_point(field_set:robot.control.OldFormat.angvel_angle_toggle)
}

// required bool dribbler_is_enabled = 12;
inline bool OldFormat::_internal_has_dribbler_is_enabled() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool OldFormat::has_dribbler_is_enabled() const {
  return _internal_has_dribbler_is_enabled();
}
inline void OldFormat::clear_dribbler_is_enabled() {
  _impl_.dribbler_is_enabled_ = false;
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline bool OldFormat::_internal_dribbler_is_enabled() const {
  return _impl_.dribbler_is_enabled_;
}
inline bool OldFormat::dribbler_is_enabled() const {
  // @@protoc_insertion_point(field_get:robot.control.OldFormat.dribbler_is_enabled)
  return _internal_dribbler_is_enabled();
}
inline void OldFormat::_internal_set_dribbler_is_enabled(bool value) {
  _impl_._has_bits_[0] |= 0x00000400u;
  _impl_.dribbler_is_enabled_ = value;
}
inline void OldFormat::set_dribbler_is_enabled(bool value) {
  _internal_set_dribbler_is_enabled(value);
  // @@protoc_insertion_point(field_set:robot.control.OldFormat.dribbler_is_enabled)
}

// required bool high_voltage = 13;
inline bool OldFormat::_internal_has_high_voltage() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool OldFormat::has_high_voltage() const {
  return _internal_has_high_voltage();
}
inline void OldFormat::clear_high_voltage() {
  _impl_.high_voltage_ = false;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline bool OldFormat::_internal_high_voltage() const {
  return _impl_.high_voltage_;
}
inline bool OldFormat::high_voltage() const {
  // @@protoc_insertion_point(field_get:robot.control.OldFormat.high_voltage)
  return _internal_high_voltage();
}
inline void OldFormat::_internal_set_high_voltage(bool value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.high_voltage_ = value;
}
inline void OldFormat::set_high_voltage(bool value) {
  _internal_set_high_voltage(value);
  // @@protoc_insertion_point(field_set:robot.control.OldFormat.high_voltage)
}

// -------------------------------------------------------------------

// KickerAndDribbler

// required .robot.control.KickerMode kicker_mode = 1;
inline bool KickerAndDribbler::_internal_has_kicker_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool KickerAndDribbler::has_kicker_mode() const {
  return _internal_has_kicker_mode();
}
inline void KickerAndDribbler::clear_kicker_mode() {
  _impl_.kicker_mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::robot::control::KickerMode KickerAndDribbler::_internal_kicker_mode() const {
  return static_cast< ::robot::control::KickerMode >(_impl_.kicker_mode_);
}
inline ::robot::control::KickerMode KickerAndDribbler::kicker_mode() const {
  // @@protoc_insertion_point(field_get:robot.control.KickerAndDribbler.kicker_mode)
  return _internal_kicker_mode();
}
inline void KickerAndDribbler::_internal_set_kicker_mode(::robot::control::KickerMode value) {
  assert(::robot::control::KickerMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.kicker_mode_ = value;
}
inline void KickerAndDribbler::set_kicker_mode(::robot::control::KickerMode value) {
  _internal_set_kicker_mode(value);
  // @@protoc_insertion_point(field_set:robot.control.KickerAndDribbler.kicker_mode)
}

// required uint32 kicker_setting = 2;
inline bool KickerAndDribbler::_internal_has_kicker_setting() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool KickerAndDribbler::has_kicker_setting() const {
  return _internal_has_kicker_setting();
}
inline void KickerAndDribbler::clear_kicker_setting() {
  _impl_.kicker_setting_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline uint32_t KickerAndDribbler::_internal_kicker_setting() const {
  return _impl_.kicker_setting_;
}
inline uint32_t KickerAndDribbler::kicker_setting() const {
  // @@protoc_insertion_point(field_get:robot.control.KickerAndDribbler.kicker_setting)
  return _internal_kicker_setting();
}
inline void KickerAndDribbler::_internal_set_kicker_setting(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.kicker_setting_ = value;
}
inline void KickerAndDribbler::set_kicker_setting(uint32_t value) {
  _internal_set_kicker_setting(value);
  // @@protoc_insertion_point(field_set:robot.control.KickerAndDribbler.kicker_setting)
}

// required uint32 dribbler_setting = 3;
inline bool KickerAndDribbler::_internal_has_dribbler_setting() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool KickerAndDribbler::has_dribbler_setting() const {
  return _internal_has_dribbler_setting();
}
inline void KickerAndDribbler::clear_dribbler_setting() {
  _impl_.dribbler_setting_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline uint32_t KickerAndDribbler::_internal_dribbler_setting() const {
  return _impl_.dribbler_setting_;
}
inline uint32_t KickerAndDribbler::dribbler_setting() const {
  // @@protoc_insertion_point(field_get:robot.control.KickerAndDribbler.dribbler_setting)
  return _internal_dribbler_setting();
}
inline void KickerAndDribbler::_internal_set_dribbler_setting(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.dribbler_setting_ = value;
}
inline void KickerAndDribbler::set_dribbler_setting(uint32_t value) {
  _internal_set_dribbler_setting(value);
  // @@protoc_insertion_point(field_set:robot.control.KickerAndDribbler.dribbler_setting)
}

// -------------------------------------------------------------------

// SpeedControl

// required float vel_x = 1;
inline bool SpeedControl::_internal_has_vel_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SpeedControl::has_vel_x() const {
  return _internal_has_vel_x();
}
inline void SpeedControl::clear_vel_x() {
  _impl_.vel_x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float SpeedControl::_internal_vel_x() const {
  return _impl_.vel_x_;
}
inline float SpeedControl::vel_x() const {
  // @@protoc_insertion_point(field_get:robot.control.SpeedControl.vel_x)
  return _internal_vel_x();
}
inline void SpeedControl::_internal_set_vel_x(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.vel_x_ = value;
}
inline void SpeedControl::set_vel_x(float value) {
  _internal_set_vel_x(value);
  // @@protoc_insertion_point(field_set:robot.control.SpeedControl.vel_x)
}

// required float vel_y = 2;
inline bool SpeedControl::_internal_has_vel_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SpeedControl::has_vel_y() const {
  return _internal_has_vel_y();
}
inline void SpeedControl::clear_vel_y() {
  _impl_.vel_y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float SpeedControl::_internal_vel_y() const {
  return _impl_.vel_y_;
}
inline float SpeedControl::vel_y() const {
  // @@protoc_insertion_point(field_get:robot.control.SpeedControl.vel_y)
  return _internal_vel_y();
}
inline void SpeedControl::_internal_set_vel_y(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.vel_y_ = value;
}
inline void SpeedControl::set_vel_y(float value) {
  _internal_set_vel_y(value);
  // @@protoc_insertion_point(field_set:robot.control.SpeedControl.vel_y)
}

// float angular_velocity = 3;
inline bool SpeedControl::_internal_has_angular_velocity() const {
  return angular_velocity_or_angle_case() == kAngularVelocity;
}
inline bool SpeedControl::has_angular_velocity() const {
  return _internal_has_angular_velocity();
}
inline void SpeedControl::set_has_angular_velocity() {
  _impl_._oneof_case_[0] = kAngularVelocity;
}
inline void SpeedControl::clear_angular_velocity() {
  if (_internal_has_angular_velocity()) {
    _impl_.angular_velocity_or_angle_.angular_velocity_ = 0;
    clear_has_angular_velocity_or_angle();
  }
}
inline float SpeedControl::_internal_angular_velocity() const {
  if (_internal_has_angular_velocity()) {
    return _impl_.angular_velocity_or_angle_.angular_velocity_;
  }
  return 0;
}
inline void SpeedControl::_internal_set_angular_velocity(float value) {
  if (!_internal_has_angular_velocity()) {
    clear_angular_velocity_or_angle();
    set_has_angular_velocity();
  }
  _impl_.angular_velocity_or_angle_.angular_velocity_ = value;
}
inline float SpeedControl::angular_velocity() const {
  // @@protoc_insertion_point(field_get:robot.control.SpeedControl.angular_velocity)
  return _internal_angular_velocity();
}
inline void SpeedControl::set_angular_velocity(float value) {
  _internal_set_angular_velocity(value);
  // @@protoc_insertion_point(field_set:robot.control.SpeedControl.angular_velocity)
}

// float delta_angle = 4;
inline bool SpeedControl::_internal_has_delta_angle() const {
  return angular_velocity_or_angle_case() == kDeltaAngle;
}
inline bool SpeedControl::has_delta_angle() const {
  return _internal_has_delta_angle();
}
inline void SpeedControl::set_has_delta_angle() {
  _impl_._oneof_case_[0] = kDeltaAngle;
}
inline void SpeedControl::clear_delta_angle() {
  if (_internal_has_delta_angle()) {
    _impl_.angular_velocity_or_angle_.delta_angle_ = 0;
    clear_has_angular_velocity_or_angle();
  }
}
inline float SpeedControl::_internal_delta_angle() const {
  if (_internal_has_delta_angle()) {
    return _impl_.angular_velocity_or_angle_.delta_angle_;
  }
  return 0;
}
inline void SpeedControl::_internal_set_delta_angle(float value) {
  if (!_internal_has_delta_angle()) {
    clear_angular_velocity_or_angle();
    set_has_delta_angle();
  }
  _impl_.angular_velocity_or_angle_.delta_angle_ = value;
}
inline float SpeedControl::delta_angle() const {
  // @@protoc_insertion_point(field_get:robot.control.SpeedControl.delta_angle)
  return _internal_delta_angle();
}
inline void SpeedControl::set_delta_angle(float value) {
  _internal_set_delta_angle(value);
  // @@protoc_insertion_point(field_set:robot.control.SpeedControl.delta_angle)
}

inline bool SpeedControl::has_angular_velocity_or_angle() const {
  return angular_velocity_or_angle_case() != ANGULAR_VELOCITY_OR_ANGLE_NOT_SET;
}
inline void SpeedControl::clear_has_angular_velocity_or_angle() {
  _impl_._oneof_case_[0] = ANGULAR_VELOCITY_OR_ANGLE_NOT_SET;
}
inline SpeedControl::AngularVelocityOrAngleCase SpeedControl::angular_velocity_or_angle_case() const {
  return SpeedControl::AngularVelocityOrAngleCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// Target

// required uint32 id = 1;
inline bool Target::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Target::has_id() const {
  return _internal_has_id();
}
inline void Target::clear_id() {
  _impl_.id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t Target::_internal_id() const {
  return _impl_.id_;
}
inline uint32_t Target::id() const {
  // @@protoc_insertion_point(field_get:robot.control.Target.id)
  return _internal_id();
}
inline void Target::_internal_set_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.id_ = value;
}
inline void Target::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:robot.control.Target.id)
}

// required float x = 2;
inline bool Target::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Target::has_x() const {
  return _internal_has_x();
}
inline void Target::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float Target::_internal_x() const {
  return _impl_.x_;
}
inline float Target::x() const {
  // @@protoc_insertion_point(field_get:robot.control.Target.x)
  return _internal_x();
}
inline void Target::_internal_set_x(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.x_ = value;
}
inline void Target::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:robot.control.Target.x)
}

// required float y = 3;
inline bool Target::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Target::has_y() const {
  return _internal_has_y();
}
inline void Target::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float Target::_internal_y() const {
  return _impl_.y_;
}
inline float Target::y() const {
  // @@protoc_insertion_point(field_get:robot.control.Target.y)
  return _internal_y();
}
inline void Target::_internal_set_y(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.y_ = value;
}
inline void Target::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:robot.control.Target.y)
}

// required float vx = 4;
inline bool Target::_internal_has_vx() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Target::has_vx() const {
  return _internal_has_vx();
}
inline void Target::clear_vx() {
  _impl_.vx_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float Target::_internal_vx() const {
  return _impl_.vx_;
}
inline float Target::vx() const {
  // @@protoc_insertion_point(field_get:robot.control.Target.vx)
  return _internal_vx();
}
inline void Target::_internal_set_vx(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.vx_ = value;
}
inline void Target::set_vx(float value) {
  _internal_set_vx(value);
  // @@protoc_insertion_point(field_set:robot.control.Target.vx)
}

// required float vy = 5;
inline bool Target::_internal_has_vy() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Target::has_vy() const {
  return _internal_has_vy();
}
inline void Target::clear_vy() {
  _impl_.vy_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline float Target::_internal_vy() const {
  return _impl_.vy_;
}
inline float Target::vy() const {
  // @@protoc_insertion_point(field_get:robot.control.Target.vy)
  return _internal_vy();
}
inline void Target::_internal_set_vy(float value) {
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.vy_ = value;
}
inline void Target::set_vy(float value) {
  _internal_set_vy(value);
  // @@protoc_insertion_point(field_set:robot.control.Target.vy)
}

// required float angle = 6;
inline bool Target::_internal_has_angle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Target::has_angle() const {
  return _internal_has_angle();
}
inline void Target::clear_angle() {
  _impl_.angle_ = 0;
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline float Target::_internal_angle() const {
  return _impl_.angle_;
}
inline float Target::angle() const {
  // @@protoc_insertion_point(field_get:robot.control.Target.angle)
  return _internal_angle();
}
inline void Target::_internal_set_angle(float value) {
  _impl_._has_bits_[0] |= 0x00000020u;
  _impl_.angle_ = value;
}
inline void Target::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:robot.control.Target.angle)
}

// -------------------------------------------------------------------

// CoordinateControl

// repeated .robot.control.Target targets = 1;
inline int CoordinateControl::_internal_targets_size() const {
  return _impl_.targets_.size();
}
inline int CoordinateControl::targets_size() const {
  return _internal_targets_size();
}
inline void CoordinateControl::clear_targets() {
  _impl_.targets_.Clear();
}
inline ::robot::control::Target* CoordinateControl::mutable_targets(int index) {
  // @@protoc_insertion_point(field_mutable:robot.control.CoordinateControl.targets)
  return _impl_.targets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::control::Target >*
CoordinateControl::mutable_targets() {
  // @@protoc_insertion_point(field_mutable_list:robot.control.CoordinateControl.targets)
  return &_impl_.targets_;
}
inline const ::robot::control::Target& CoordinateControl::_internal_targets(int index) const {
  return _impl_.targets_.Get(index);
}
inline const ::robot::control::Target& CoordinateControl::targets(int index) const {
  // @@protoc_insertion_point(field_get:robot.control.CoordinateControl.targets)
  return _internal_targets(index);
}
inline ::robot::control::Target* CoordinateControl::_internal_add_targets() {
  return _impl_.targets_.Add();
}
inline ::robot::control::Target* CoordinateControl::add_targets() {
  ::robot::control::Target* _add = _internal_add_targets();
  // @@protoc_insertion_point(field_add:robot.control.CoordinateControl.targets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::robot::control::Target >&
CoordinateControl::targets() const {
  // @@protoc_insertion_point(field_list:robot.control.CoordinateControl.targets)
  return _impl_.targets_;
}

// -------------------------------------------------------------------

// GlobalCoordinates

// required float x = 1;
inline bool GlobalCoordinates::_internal_has_x() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GlobalCoordinates::has_x() const {
  return _internal_has_x();
}
inline void GlobalCoordinates::clear_x() {
  _impl_.x_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float GlobalCoordinates::_internal_x() const {
  return _impl_.x_;
}
inline float GlobalCoordinates::x() const {
  // @@protoc_insertion_point(field_get:robot.control.GlobalCoordinates.x)
  return _internal_x();
}
inline void GlobalCoordinates::_internal_set_x(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.x_ = value;
}
inline void GlobalCoordinates::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:robot.control.GlobalCoordinates.x)
}

// required float y = 2;
inline bool GlobalCoordinates::_internal_has_y() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GlobalCoordinates::has_y() const {
  return _internal_has_y();
}
inline void GlobalCoordinates::clear_y() {
  _impl_.y_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float GlobalCoordinates::_internal_y() const {
  return _impl_.y_;
}
inline float GlobalCoordinates::y() const {
  // @@protoc_insertion_point(field_get:robot.control.GlobalCoordinates.y)
  return _internal_y();
}
inline void GlobalCoordinates::_internal_set_y(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.y_ = value;
}
inline void GlobalCoordinates::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:robot.control.GlobalCoordinates.y)
}

// required float angle = 3;
inline bool GlobalCoordinates::_internal_has_angle() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GlobalCoordinates::has_angle() const {
  return _internal_has_angle();
}
inline void GlobalCoordinates::clear_angle() {
  _impl_.angle_ = 0;
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline float GlobalCoordinates::_internal_angle() const {
  return _impl_.angle_;
}
inline float GlobalCoordinates::angle() const {
  // @@protoc_insertion_point(field_get:robot.control.GlobalCoordinates.angle)
  return _internal_angle();
}
inline void GlobalCoordinates::_internal_set_angle(float value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.angle_ = value;
}
inline void GlobalCoordinates::set_angle(float value) {
  _internal_set_angle(value);
  // @@protoc_insertion_point(field_set:robot.control.GlobalCoordinates.angle)
}

// -------------------------------------------------------------------

// CapVelAndAccel

// required float max_vel = 1;
inline bool CapVelAndAccel::_internal_has_max_vel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CapVelAndAccel::has_max_vel() const {
  return _internal_has_max_vel();
}
inline void CapVelAndAccel::clear_max_vel() {
  _impl_.max_vel_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline float CapVelAndAccel::_internal_max_vel() const {
  return _impl_.max_vel_;
}
inline float CapVelAndAccel::max_vel() const {
  // @@protoc_insertion_point(field_get:robot.control.CapVelAndAccel.max_vel)
  return _internal_max_vel();
}
inline void CapVelAndAccel::_internal_set_max_vel(float value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.max_vel_ = value;
}
inline void CapVelAndAccel::set_max_vel(float value) {
  _internal_set_max_vel(value);
  // @@protoc_insertion_point(field_set:robot.control.CapVelAndAccel.max_vel)
}

// required float max_accel = 2;
inline bool CapVelAndAccel::_internal_has_max_accel() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CapVelAndAccel::has_max_accel() const {
  return _internal_has_max_accel();
}
inline void CapVelAndAccel::clear_max_accel() {
  _impl_.max_accel_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline float CapVelAndAccel::_internal_max_accel() const {
  return _impl_.max_accel_;
}
inline float CapVelAndAccel::max_accel() const {
  // @@protoc_insertion_point(field_get:robot.control.CapVelAndAccel.max_accel)
  return _internal_max_accel();
}
inline void CapVelAndAccel::_internal_set_max_accel(float value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.max_accel_ = value;
}
inline void CapVelAndAccel::set_max_accel(float value) {
  _internal_set_max_accel(value);
  // @@protoc_insertion_point(field_set:robot.control.CapVelAndAccel.max_accel)
}

// -------------------------------------------------------------------

// RobotCommand

// required uint32 robot_id = 1;
inline bool RobotCommand::_internal_has_robot_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool RobotCommand::has_robot_id() const {
  return _internal_has_robot_id();
}
inline void RobotCommand::clear_robot_id() {
  _impl_.robot_id_ = 0u;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline uint32_t RobotCommand::_internal_robot_id() const {
  return _impl_.robot_id_;
}
inline uint32_t RobotCommand::robot_id() const {
  // @@protoc_insertion_point(field_get:robot.control.RobotCommand.robot_id)
  return _internal_robot_id();
}
inline void RobotCommand::_internal_set_robot_id(uint32_t value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.robot_id_ = value;
}
inline void RobotCommand::set_robot_id(uint32_t value) {
  _internal_set_robot_id(value);
  // @@protoc_insertion_point(field_set:robot.control.RobotCommand.robot_id)
}

// .robot.control.OldFormat old_format = 2;
inline bool RobotCommand::_internal_has_old_format() const {
  return control_case() == kOldFormat;
}
inline bool RobotCommand::has_old_format() const {
  return _internal_has_old_format();
}
inline void RobotCommand::set_has_old_format() {
  _impl_._oneof_case_[0] = kOldFormat;
}
inline void RobotCommand::clear_old_format() {
  if (_internal_has_old_format()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.control_.old_format_;
    }
    clear_has_control();
  }
}
inline ::robot::control::OldFormat* RobotCommand::release_old_format() {
  // @@protoc_insertion_point(field_release:robot.control.RobotCommand.old_format)
  if (_internal_has_old_format()) {
    clear_has_control();
    ::robot::control::OldFormat* temp = _impl_.control_.old_format_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.control_.old_format_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::robot::control::OldFormat& RobotCommand::_internal_old_format() const {
  return _internal_has_old_format()
      ? *_impl_.control_.old_format_
      : reinterpret_cast< ::robot::control::OldFormat&>(::robot::control::_OldFormat_default_instance_);
}
inline const ::robot::control::OldFormat& RobotCommand::old_format() const {
  // @@protoc_insertion_point(field_get:robot.control.RobotCommand.old_format)
  return _internal_old_format();
}
inline ::robot::control::OldFormat* RobotCommand::unsafe_arena_release_old_format() {
  // @@protoc_insertion_point(field_unsafe_arena_release:robot.control.RobotCommand.old_format)
  if (_internal_has_old_format()) {
    clear_has_control();
    ::robot::control::OldFormat* temp = _impl_.control_.old_format_;
    _impl_.control_.old_format_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RobotCommand::unsafe_arena_set_allocated_old_format(::robot::control::OldFormat* old_format) {
  clear_control();
  if (old_format) {
    set_has_old_format();
    _impl_.control_.old_format_ = old_format;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.control.RobotCommand.old_format)
}
inline ::robot::control::OldFormat* RobotCommand::_internal_mutable_old_format() {
  if (!_internal_has_old_format()) {
    clear_control();
    set_has_old_format();
    _impl_.control_.old_format_ = CreateMaybeMessage< ::robot::control::OldFormat >(GetArenaForAllocation());
  }
  return _impl_.control_.old_format_;
}
inline ::robot::control::OldFormat* RobotCommand::mutable_old_format() {
  ::robot::control::OldFormat* _msg = _internal_mutable_old_format();
  // @@protoc_insertion_point(field_mutable:robot.control.RobotCommand.old_format)
  return _msg;
}

// .robot.control.KickerAndDribbler kicker_and_dribbler = 3;
inline bool RobotCommand::_internal_has_kicker_and_dribbler() const {
  return control_case() == kKickerAndDribbler;
}
inline bool RobotCommand::has_kicker_and_dribbler() const {
  return _internal_has_kicker_and_dribbler();
}
inline void RobotCommand::set_has_kicker_and_dribbler() {
  _impl_._oneof_case_[0] = kKickerAndDribbler;
}
inline void RobotCommand::clear_kicker_and_dribbler() {
  if (_internal_has_kicker_and_dribbler()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.control_.kicker_and_dribbler_;
    }
    clear_has_control();
  }
}
inline ::robot::control::KickerAndDribbler* RobotCommand::release_kicker_and_dribbler() {
  // @@protoc_insertion_point(field_release:robot.control.RobotCommand.kicker_and_dribbler)
  if (_internal_has_kicker_and_dribbler()) {
    clear_has_control();
    ::robot::control::KickerAndDribbler* temp = _impl_.control_.kicker_and_dribbler_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.control_.kicker_and_dribbler_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::robot::control::KickerAndDribbler& RobotCommand::_internal_kicker_and_dribbler() const {
  return _internal_has_kicker_and_dribbler()
      ? *_impl_.control_.kicker_and_dribbler_
      : reinterpret_cast< ::robot::control::KickerAndDribbler&>(::robot::control::_KickerAndDribbler_default_instance_);
}
inline const ::robot::control::KickerAndDribbler& RobotCommand::kicker_and_dribbler() const {
  // @@protoc_insertion_point(field_get:robot.control.RobotCommand.kicker_and_dribbler)
  return _internal_kicker_and_dribbler();
}
inline ::robot::control::KickerAndDribbler* RobotCommand::unsafe_arena_release_kicker_and_dribbler() {
  // @@protoc_insertion_point(field_unsafe_arena_release:robot.control.RobotCommand.kicker_and_dribbler)
  if (_internal_has_kicker_and_dribbler()) {
    clear_has_control();
    ::robot::control::KickerAndDribbler* temp = _impl_.control_.kicker_and_dribbler_;
    _impl_.control_.kicker_and_dribbler_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RobotCommand::unsafe_arena_set_allocated_kicker_and_dribbler(::robot::control::KickerAndDribbler* kicker_and_dribbler) {
  clear_control();
  if (kicker_and_dribbler) {
    set_has_kicker_and_dribbler();
    _impl_.control_.kicker_and_dribbler_ = kicker_and_dribbler;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.control.RobotCommand.kicker_and_dribbler)
}
inline ::robot::control::KickerAndDribbler* RobotCommand::_internal_mutable_kicker_and_dribbler() {
  if (!_internal_has_kicker_and_dribbler()) {
    clear_control();
    set_has_kicker_and_dribbler();
    _impl_.control_.kicker_and_dribbler_ = CreateMaybeMessage< ::robot::control::KickerAndDribbler >(GetArenaForAllocation());
  }
  return _impl_.control_.kicker_and_dribbler_;
}
inline ::robot::control::KickerAndDribbler* RobotCommand::mutable_kicker_and_dribbler() {
  ::robot::control::KickerAndDribbler* _msg = _internal_mutable_kicker_and_dribbler();
  // @@protoc_insertion_point(field_mutable:robot.control.RobotCommand.kicker_and_dribbler)
  return _msg;
}

// .robot.control.SpeedControl speed_control = 4;
inline bool RobotCommand::_internal_has_speed_control() const {
  return control_case() == kSpeedControl;
}
inline bool RobotCommand::has_speed_control() const {
  return _internal_has_speed_control();
}
inline void RobotCommand::set_has_speed_control() {
  _impl_._oneof_case_[0] = kSpeedControl;
}
inline void RobotCommand::clear_speed_control() {
  if (_internal_has_speed_control()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.control_.speed_control_;
    }
    clear_has_control();
  }
}
inline ::robot::control::SpeedControl* RobotCommand::release_speed_control() {
  // @@protoc_insertion_point(field_release:robot.control.RobotCommand.speed_control)
  if (_internal_has_speed_control()) {
    clear_has_control();
    ::robot::control::SpeedControl* temp = _impl_.control_.speed_control_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.control_.speed_control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::robot::control::SpeedControl& RobotCommand::_internal_speed_control() const {
  return _internal_has_speed_control()
      ? *_impl_.control_.speed_control_
      : reinterpret_cast< ::robot::control::SpeedControl&>(::robot::control::_SpeedControl_default_instance_);
}
inline const ::robot::control::SpeedControl& RobotCommand::speed_control() const {
  // @@protoc_insertion_point(field_get:robot.control.RobotCommand.speed_control)
  return _internal_speed_control();
}
inline ::robot::control::SpeedControl* RobotCommand::unsafe_arena_release_speed_control() {
  // @@protoc_insertion_point(field_unsafe_arena_release:robot.control.RobotCommand.speed_control)
  if (_internal_has_speed_control()) {
    clear_has_control();
    ::robot::control::SpeedControl* temp = _impl_.control_.speed_control_;
    _impl_.control_.speed_control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RobotCommand::unsafe_arena_set_allocated_speed_control(::robot::control::SpeedControl* speed_control) {
  clear_control();
  if (speed_control) {
    set_has_speed_control();
    _impl_.control_.speed_control_ = speed_control;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.control.RobotCommand.speed_control)
}
inline ::robot::control::SpeedControl* RobotCommand::_internal_mutable_speed_control() {
  if (!_internal_has_speed_control()) {
    clear_control();
    set_has_speed_control();
    _impl_.control_.speed_control_ = CreateMaybeMessage< ::robot::control::SpeedControl >(GetArenaForAllocation());
  }
  return _impl_.control_.speed_control_;
}
inline ::robot::control::SpeedControl* RobotCommand::mutable_speed_control() {
  ::robot::control::SpeedControl* _msg = _internal_mutable_speed_control();
  // @@protoc_insertion_point(field_mutable:robot.control.RobotCommand.speed_control)
  return _msg;
}

// .robot.control.CoordinateControl coordinate_control = 5;
inline bool RobotCommand::_internal_has_coordinate_control() const {
  return control_case() == kCoordinateControl;
}
inline bool RobotCommand::has_coordinate_control() const {
  return _internal_has_coordinate_control();
}
inline void RobotCommand::set_has_coordinate_control() {
  _impl_._oneof_case_[0] = kCoordinateControl;
}
inline void RobotCommand::clear_coordinate_control() {
  if (_internal_has_coordinate_control()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.control_.coordinate_control_;
    }
    clear_has_control();
  }
}
inline ::robot::control::CoordinateControl* RobotCommand::release_coordinate_control() {
  // @@protoc_insertion_point(field_release:robot.control.RobotCommand.coordinate_control)
  if (_internal_has_coordinate_control()) {
    clear_has_control();
    ::robot::control::CoordinateControl* temp = _impl_.control_.coordinate_control_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.control_.coordinate_control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::robot::control::CoordinateControl& RobotCommand::_internal_coordinate_control() const {
  return _internal_has_coordinate_control()
      ? *_impl_.control_.coordinate_control_
      : reinterpret_cast< ::robot::control::CoordinateControl&>(::robot::control::_CoordinateControl_default_instance_);
}
inline const ::robot::control::CoordinateControl& RobotCommand::coordinate_control() const {
  // @@protoc_insertion_point(field_get:robot.control.RobotCommand.coordinate_control)
  return _internal_coordinate_control();
}
inline ::robot::control::CoordinateControl* RobotCommand::unsafe_arena_release_coordinate_control() {
  // @@protoc_insertion_point(field_unsafe_arena_release:robot.control.RobotCommand.coordinate_control)
  if (_internal_has_coordinate_control()) {
    clear_has_control();
    ::robot::control::CoordinateControl* temp = _impl_.control_.coordinate_control_;
    _impl_.control_.coordinate_control_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RobotCommand::unsafe_arena_set_allocated_coordinate_control(::robot::control::CoordinateControl* coordinate_control) {
  clear_control();
  if (coordinate_control) {
    set_has_coordinate_control();
    _impl_.control_.coordinate_control_ = coordinate_control;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.control.RobotCommand.coordinate_control)
}
inline ::robot::control::CoordinateControl* RobotCommand::_internal_mutable_coordinate_control() {
  if (!_internal_has_coordinate_control()) {
    clear_control();
    set_has_coordinate_control();
    _impl_.control_.coordinate_control_ = CreateMaybeMessage< ::robot::control::CoordinateControl >(GetArenaForAllocation());
  }
  return _impl_.control_.coordinate_control_;
}
inline ::robot::control::CoordinateControl* RobotCommand::mutable_coordinate_control() {
  ::robot::control::CoordinateControl* _msg = _internal_mutable_coordinate_control();
  // @@protoc_insertion_point(field_mutable:robot.control.RobotCommand.coordinate_control)
  return _msg;
}

// .robot.control.GlobalCoordinates global_coordinates = 6;
inline bool RobotCommand::_internal_has_global_coordinates() const {
  return control_case() == kGlobalCoordinates;
}
inline bool RobotCommand::has_global_coordinates() const {
  return _internal_has_global_coordinates();
}
inline void RobotCommand::set_has_global_coordinates() {
  _impl_._oneof_case_[0] = kGlobalCoordinates;
}
inline void RobotCommand::clear_global_coordinates() {
  if (_internal_has_global_coordinates()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.control_.global_coordinates_;
    }
    clear_has_control();
  }
}
inline ::robot::control::GlobalCoordinates* RobotCommand::release_global_coordinates() {
  // @@protoc_insertion_point(field_release:robot.control.RobotCommand.global_coordinates)
  if (_internal_has_global_coordinates()) {
    clear_has_control();
    ::robot::control::GlobalCoordinates* temp = _impl_.control_.global_coordinates_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.control_.global_coordinates_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::robot::control::GlobalCoordinates& RobotCommand::_internal_global_coordinates() const {
  return _internal_has_global_coordinates()
      ? *_impl_.control_.global_coordinates_
      : reinterpret_cast< ::robot::control::GlobalCoordinates&>(::robot::control::_GlobalCoordinates_default_instance_);
}
inline const ::robot::control::GlobalCoordinates& RobotCommand::global_coordinates() const {
  // @@protoc_insertion_point(field_get:robot.control.RobotCommand.global_coordinates)
  return _internal_global_coordinates();
}
inline ::robot::control::GlobalCoordinates* RobotCommand::unsafe_arena_release_global_coordinates() {
  // @@protoc_insertion_point(field_unsafe_arena_release:robot.control.RobotCommand.global_coordinates)
  if (_internal_has_global_coordinates()) {
    clear_has_control();
    ::robot::control::GlobalCoordinates* temp = _impl_.control_.global_coordinates_;
    _impl_.control_.global_coordinates_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RobotCommand::unsafe_arena_set_allocated_global_coordinates(::robot::control::GlobalCoordinates* global_coordinates) {
  clear_control();
  if (global_coordinates) {
    set_has_global_coordinates();
    _impl_.control_.global_coordinates_ = global_coordinates;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.control.RobotCommand.global_coordinates)
}
inline ::robot::control::GlobalCoordinates* RobotCommand::_internal_mutable_global_coordinates() {
  if (!_internal_has_global_coordinates()) {
    clear_control();
    set_has_global_coordinates();
    _impl_.control_.global_coordinates_ = CreateMaybeMessage< ::robot::control::GlobalCoordinates >(GetArenaForAllocation());
  }
  return _impl_.control_.global_coordinates_;
}
inline ::robot::control::GlobalCoordinates* RobotCommand::mutable_global_coordinates() {
  ::robot::control::GlobalCoordinates* _msg = _internal_mutable_global_coordinates();
  // @@protoc_insertion_point(field_mutable:robot.control.RobotCommand.global_coordinates)
  return _msg;
}

// .robot.control.CapVelAndAccel cap_vel_and_accel = 7;
inline bool RobotCommand::_internal_has_cap_vel_and_accel() const {
  return control_case() == kCapVelAndAccel;
}
inline bool RobotCommand::has_cap_vel_and_accel() const {
  return _internal_has_cap_vel_and_accel();
}
inline void RobotCommand::set_has_cap_vel_and_accel() {
  _impl_._oneof_case_[0] = kCapVelAndAccel;
}
inline void RobotCommand::clear_cap_vel_and_accel() {
  if (_internal_has_cap_vel_and_accel()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.control_.cap_vel_and_accel_;
    }
    clear_has_control();
  }
}
inline ::robot::control::CapVelAndAccel* RobotCommand::release_cap_vel_and_accel() {
  // @@protoc_insertion_point(field_release:robot.control.RobotCommand.cap_vel_and_accel)
  if (_internal_has_cap_vel_and_accel()) {
    clear_has_control();
    ::robot::control::CapVelAndAccel* temp = _impl_.control_.cap_vel_and_accel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.control_.cap_vel_and_accel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::robot::control::CapVelAndAccel& RobotCommand::_internal_cap_vel_and_accel() const {
  return _internal_has_cap_vel_and_accel()
      ? *_impl_.control_.cap_vel_and_accel_
      : reinterpret_cast< ::robot::control::CapVelAndAccel&>(::robot::control::_CapVelAndAccel_default_instance_);
}
inline const ::robot::control::CapVelAndAccel& RobotCommand::cap_vel_and_accel() const {
  // @@protoc_insertion_point(field_get:robot.control.RobotCommand.cap_vel_and_accel)
  return _internal_cap_vel_and_accel();
}
inline ::robot::control::CapVelAndAccel* RobotCommand::unsafe_arena_release_cap_vel_and_accel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:robot.control.RobotCommand.cap_vel_and_accel)
  if (_internal_has_cap_vel_and_accel()) {
    clear_has_control();
    ::robot::control::CapVelAndAccel* temp = _impl_.control_.cap_vel_and_accel_;
    _impl_.control_.cap_vel_and_accel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RobotCommand::unsafe_arena_set_allocated_cap_vel_and_accel(::robot::control::CapVelAndAccel* cap_vel_and_accel) {
  clear_control();
  if (cap_vel_and_accel) {
    set_has_cap_vel_and_accel();
    _impl_.control_.cap_vel_and_accel_ = cap_vel_and_accel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:robot.control.RobotCommand.cap_vel_and_accel)
}
inline ::robot::control::CapVelAndAccel* RobotCommand::_internal_mutable_cap_vel_and_accel() {
  if (!_internal_has_cap_vel_and_accel()) {
    clear_control();
    set_has_cap_vel_and_accel();
    _impl_.control_.cap_vel_and_accel_ = CreateMaybeMessage< ::robot::control::CapVelAndAccel >(GetArenaForAllocation());
  }
  return _impl_.control_.cap_vel_and_accel_;
}
inline ::robot::control::CapVelAndAccel* RobotCommand::mutable_cap_vel_and_accel() {
  ::robot::control::CapVelAndAccel* _msg = _internal_mutable_cap_vel_and_accel();
  // @@protoc_insertion_point(field_mutable:robot.control.RobotCommand.cap_vel_and_accel)
  return _msg;
}

inline bool RobotCommand::has_control() const {
  return control_case() != CONTROL_NOT_SET;
}
inline void RobotCommand::clear_has_control() {
  _impl_._oneof_case_[0] = CONTROL_NOT_SET;
}
inline RobotCommand::ControlCase RobotCommand::control_case() const {
  return RobotCommand::ControlCase(_impl_._oneof_case_[0]);
}
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace control
}  // namespace robot

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::robot::control::RobotControlType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::robot::control::RobotControlType>() {
  return ::robot::control::RobotControlType_descriptor();
}
template <> struct is_proto_enum< ::robot::control::KickerMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::robot::control::KickerMode>() {
  return ::robot::control::KickerMode_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_robot_2fcontrol_2eproto
