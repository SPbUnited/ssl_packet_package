// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ether/draw.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ether_2fdraw_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ether_2fdraw_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ether_2fdraw_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ether_2fdraw_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ether_2fdraw_2eproto;
namespace ether {
namespace draw {
class Arrow;
struct ArrowDefaultTypeInternal;
extern ArrowDefaultTypeInternal _Arrow_default_instance_;
class Ball;
struct BallDefaultTypeInternal;
extern BallDefaultTypeInternal _Ball_default_instance_;
class Circle;
struct CircleDefaultTypeInternal;
extern CircleDefaultTypeInternal _Circle_default_instance_;
class DrawCommand;
struct DrawCommandDefaultTypeInternal;
extern DrawCommandDefaultTypeInternal _DrawCommand_default_instance_;
class DrawCommand_LayersEntry_DoNotUse;
struct DrawCommand_LayersEntry_DoNotUseDefaultTypeInternal;
extern DrawCommand_LayersEntry_DoNotUseDefaultTypeInternal _DrawCommand_LayersEntry_DoNotUse_default_instance_;
class DrawObject;
struct DrawObjectDefaultTypeInternal;
extern DrawObjectDefaultTypeInternal _DrawObject_default_instance_;
class Layer;
struct LayerDefaultTypeInternal;
extern LayerDefaultTypeInternal _Layer_default_instance_;
class Line;
struct LineDefaultTypeInternal;
extern LineDefaultTypeInternal _Line_default_instance_;
class Polygon;
struct PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class Rect;
struct RectDefaultTypeInternal;
extern RectDefaultTypeInternal _Rect_default_instance_;
class RobotBlu;
struct RobotBluDefaultTypeInternal;
extern RobotBluDefaultTypeInternal _RobotBlu_default_instance_;
class RobotYel;
struct RobotYelDefaultTypeInternal;
extern RobotYelDefaultTypeInternal _RobotYel_default_instance_;
}  // namespace draw
}  // namespace ether
PROTOBUF_NAMESPACE_OPEN
template<> ::ether::draw::Arrow* Arena::CreateMaybeMessage<::ether::draw::Arrow>(Arena*);
template<> ::ether::draw::Ball* Arena::CreateMaybeMessage<::ether::draw::Ball>(Arena*);
template<> ::ether::draw::Circle* Arena::CreateMaybeMessage<::ether::draw::Circle>(Arena*);
template<> ::ether::draw::DrawCommand* Arena::CreateMaybeMessage<::ether::draw::DrawCommand>(Arena*);
template<> ::ether::draw::DrawCommand_LayersEntry_DoNotUse* Arena::CreateMaybeMessage<::ether::draw::DrawCommand_LayersEntry_DoNotUse>(Arena*);
template<> ::ether::draw::DrawObject* Arena::CreateMaybeMessage<::ether::draw::DrawObject>(Arena*);
template<> ::ether::draw::Layer* Arena::CreateMaybeMessage<::ether::draw::Layer>(Arena*);
template<> ::ether::draw::Line* Arena::CreateMaybeMessage<::ether::draw::Line>(Arena*);
template<> ::ether::draw::Polygon* Arena::CreateMaybeMessage<::ether::draw::Polygon>(Arena*);
template<> ::ether::draw::Rect* Arena::CreateMaybeMessage<::ether::draw::Rect>(Arena*);
template<> ::ether::draw::RobotBlu* Arena::CreateMaybeMessage<::ether::draw::RobotBlu>(Arena*);
template<> ::ether::draw::RobotYel* Arena::CreateMaybeMessage<::ether::draw::RobotYel>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ether {
namespace draw {

// ===================================================================

class DrawCommand_LayersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DrawCommand_LayersEntry_DoNotUse, 
    std::string, ::ether::draw::Layer,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DrawCommand_LayersEntry_DoNotUse, 
    std::string, ::ether::draw::Layer,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  DrawCommand_LayersEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR DrawCommand_LayersEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit DrawCommand_LayersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DrawCommand_LayersEntry_DoNotUse& other);
  static const DrawCommand_LayersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DrawCommand_LayersEntry_DoNotUse*>(&_DrawCommand_LayersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "ether.draw.DrawCommand.LayersEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_ether_2fdraw_2eproto;
};

// -------------------------------------------------------------------

class DrawCommand final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ether.draw.DrawCommand) */ {
 public:
  inline DrawCommand() : DrawCommand(nullptr) {}
  ~DrawCommand() override;
  explicit PROTOBUF_CONSTEXPR DrawCommand(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrawCommand(const DrawCommand& from);
  DrawCommand(DrawCommand&& from) noexcept
    : DrawCommand() {
    *this = ::std::move(from);
  }

  inline DrawCommand& operator=(const DrawCommand& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrawCommand& operator=(DrawCommand&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrawCommand& default_instance() {
    return *internal_default_instance();
  }
  static inline const DrawCommand* internal_default_instance() {
    return reinterpret_cast<const DrawCommand*>(
               &_DrawCommand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DrawCommand& a, DrawCommand& b) {
    a.Swap(&b);
  }
  inline void Swap(DrawCommand* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrawCommand* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrawCommand* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrawCommand>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DrawCommand& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DrawCommand& from) {
    DrawCommand::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrawCommand* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ether.draw.DrawCommand";
  }
  protected:
  explicit DrawCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kLayersFieldNumber = 1,
  };
  // map<string, .ether.draw.Layer> layers = 1;
  int layers_size() const;
  private:
  int _internal_layers_size() const;
  public:
  void clear_layers();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ether::draw::Layer >&
      _internal_layers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ether::draw::Layer >*
      _internal_mutable_layers();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ether::draw::Layer >&
      layers() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ether::draw::Layer >*
      mutable_layers();

  // @@protoc_insertion_point(class_scope:ether.draw.DrawCommand)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        DrawCommand_LayersEntry_DoNotUse,
        std::string, ::ether::draw::Layer,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> layers_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ether_2fdraw_2eproto;
};
// -------------------------------------------------------------------

class Layer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ether.draw.Layer) */ {
 public:
  inline Layer() : Layer(nullptr) {}
  ~Layer() override;
  explicit PROTOBUF_CONSTEXPR Layer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Layer(const Layer& from);
  Layer(Layer&& from) noexcept
    : Layer() {
    *this = ::std::move(from);
  }

  inline Layer& operator=(const Layer& from) {
    CopyFrom(from);
    return *this;
  }
  inline Layer& operator=(Layer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Layer& default_instance() {
    return *internal_default_instance();
  }
  static inline const Layer* internal_default_instance() {
    return reinterpret_cast<const Layer*>(
               &_Layer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Layer& a, Layer& b) {
    a.Swap(&b);
  }
  inline void Swap(Layer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Layer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Layer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Layer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Layer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Layer& from) {
    Layer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Layer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ether.draw.Layer";
  }
  protected:
  explicit Layer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kIsVisibleFieldNumber = 2,
  };
  // repeated .ether.draw.DrawObject data = 1;
  int data_size() const;
  private:
  int _internal_data_size() const;
  public:
  void clear_data();
  ::ether::draw::DrawObject* mutable_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ether::draw::DrawObject >*
      mutable_data();
  private:
  const ::ether::draw::DrawObject& _internal_data(int index) const;
  ::ether::draw::DrawObject* _internal_add_data();
  public:
  const ::ether::draw::DrawObject& data(int index) const;
  ::ether::draw::DrawObject* add_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ether::draw::DrawObject >&
      data() const;

  // bool is_visible = 2;
  void clear_is_visible();
  bool is_visible() const;
  void set_is_visible(bool value);
  private:
  bool _internal_is_visible() const;
  void _internal_set_is_visible(bool value);
  public:

  // @@protoc_insertion_point(class_scope:ether.draw.Layer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ether::draw::DrawObject > data_;
    bool is_visible_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ether_2fdraw_2eproto;
};
// -------------------------------------------------------------------

class DrawObject final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ether.draw.DrawObject) */ {
 public:
  inline DrawObject() : DrawObject(nullptr) {}
  ~DrawObject() override;
  explicit PROTOBUF_CONSTEXPR DrawObject(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DrawObject(const DrawObject& from);
  DrawObject(DrawObject&& from) noexcept
    : DrawObject() {
    *this = ::std::move(from);
  }

  inline DrawObject& operator=(const DrawObject& from) {
    CopyFrom(from);
    return *this;
  }
  inline DrawObject& operator=(DrawObject&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DrawObject& default_instance() {
    return *internal_default_instance();
  }
  enum ObjectCase {
    kRobotYel = 1,
    kRobotBlu = 2,
    kBall = 3,
    kLine = 4,
    kArrow = 5,
    kPolygon = 6,
    kRect = 7,
    kCircle = 8,
    OBJECT_NOT_SET = 0,
  };

  static inline const DrawObject* internal_default_instance() {
    return reinterpret_cast<const DrawObject*>(
               &_DrawObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DrawObject& a, DrawObject& b) {
    a.Swap(&b);
  }
  inline void Swap(DrawObject* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DrawObject* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DrawObject* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DrawObject>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DrawObject& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DrawObject& from) {
    DrawObject::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DrawObject* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ether.draw.DrawObject";
  }
  protected:
  explicit DrawObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRobotYelFieldNumber = 1,
    kRobotBluFieldNumber = 2,
    kBallFieldNumber = 3,
    kLineFieldNumber = 4,
    kArrowFieldNumber = 5,
    kPolygonFieldNumber = 6,
    kRectFieldNumber = 7,
    kCircleFieldNumber = 8,
  };
  // .ether.draw.RobotYel robot_yel = 1;
  bool has_robot_yel() const;
  private:
  bool _internal_has_robot_yel() const;
  public:
  void clear_robot_yel();
  const ::ether::draw::RobotYel& robot_yel() const;
  PROTOBUF_NODISCARD ::ether::draw::RobotYel* release_robot_yel();
  ::ether::draw::RobotYel* mutable_robot_yel();
  void set_allocated_robot_yel(::ether::draw::RobotYel* robot_yel);
  private:
  const ::ether::draw::RobotYel& _internal_robot_yel() const;
  ::ether::draw::RobotYel* _internal_mutable_robot_yel();
  public:
  void unsafe_arena_set_allocated_robot_yel(
      ::ether::draw::RobotYel* robot_yel);
  ::ether::draw::RobotYel* unsafe_arena_release_robot_yel();

  // .ether.draw.RobotBlu robot_blu = 2;
  bool has_robot_blu() const;
  private:
  bool _internal_has_robot_blu() const;
  public:
  void clear_robot_blu();
  const ::ether::draw::RobotBlu& robot_blu() const;
  PROTOBUF_NODISCARD ::ether::draw::RobotBlu* release_robot_blu();
  ::ether::draw::RobotBlu* mutable_robot_blu();
  void set_allocated_robot_blu(::ether::draw::RobotBlu* robot_blu);
  private:
  const ::ether::draw::RobotBlu& _internal_robot_blu() const;
  ::ether::draw::RobotBlu* _internal_mutable_robot_blu();
  public:
  void unsafe_arena_set_allocated_robot_blu(
      ::ether::draw::RobotBlu* robot_blu);
  ::ether::draw::RobotBlu* unsafe_arena_release_robot_blu();

  // .ether.draw.Ball ball = 3;
  bool has_ball() const;
  private:
  bool _internal_has_ball() const;
  public:
  void clear_ball();
  const ::ether::draw::Ball& ball() const;
  PROTOBUF_NODISCARD ::ether::draw::Ball* release_ball();
  ::ether::draw::Ball* mutable_ball();
  void set_allocated_ball(::ether::draw::Ball* ball);
  private:
  const ::ether::draw::Ball& _internal_ball() const;
  ::ether::draw::Ball* _internal_mutable_ball();
  public:
  void unsafe_arena_set_allocated_ball(
      ::ether::draw::Ball* ball);
  ::ether::draw::Ball* unsafe_arena_release_ball();

  // .ether.draw.Line line = 4;
  bool has_line() const;
  private:
  bool _internal_has_line() const;
  public:
  void clear_line();
  const ::ether::draw::Line& line() const;
  PROTOBUF_NODISCARD ::ether::draw::Line* release_line();
  ::ether::draw::Line* mutable_line();
  void set_allocated_line(::ether::draw::Line* line);
  private:
  const ::ether::draw::Line& _internal_line() const;
  ::ether::draw::Line* _internal_mutable_line();
  public:
  void unsafe_arena_set_allocated_line(
      ::ether::draw::Line* line);
  ::ether::draw::Line* unsafe_arena_release_line();

  // .ether.draw.Arrow arrow = 5;
  bool has_arrow() const;
  private:
  bool _internal_has_arrow() const;
  public:
  void clear_arrow();
  const ::ether::draw::Arrow& arrow() const;
  PROTOBUF_NODISCARD ::ether::draw::Arrow* release_arrow();
  ::ether::draw::Arrow* mutable_arrow();
  void set_allocated_arrow(::ether::draw::Arrow* arrow);
  private:
  const ::ether::draw::Arrow& _internal_arrow() const;
  ::ether::draw::Arrow* _internal_mutable_arrow();
  public:
  void unsafe_arena_set_allocated_arrow(
      ::ether::draw::Arrow* arrow);
  ::ether::draw::Arrow* unsafe_arena_release_arrow();

  // .ether.draw.Polygon polygon = 6;
  bool has_polygon() const;
  private:
  bool _internal_has_polygon() const;
  public:
  void clear_polygon();
  const ::ether::draw::Polygon& polygon() const;
  PROTOBUF_NODISCARD ::ether::draw::Polygon* release_polygon();
  ::ether::draw::Polygon* mutable_polygon();
  void set_allocated_polygon(::ether::draw::Polygon* polygon);
  private:
  const ::ether::draw::Polygon& _internal_polygon() const;
  ::ether::draw::Polygon* _internal_mutable_polygon();
  public:
  void unsafe_arena_set_allocated_polygon(
      ::ether::draw::Polygon* polygon);
  ::ether::draw::Polygon* unsafe_arena_release_polygon();

  // .ether.draw.Rect rect = 7;
  bool has_rect() const;
  private:
  bool _internal_has_rect() const;
  public:
  void clear_rect();
  const ::ether::draw::Rect& rect() const;
  PROTOBUF_NODISCARD ::ether::draw::Rect* release_rect();
  ::ether::draw::Rect* mutable_rect();
  void set_allocated_rect(::ether::draw::Rect* rect);
  private:
  const ::ether::draw::Rect& _internal_rect() const;
  ::ether::draw::Rect* _internal_mutable_rect();
  public:
  void unsafe_arena_set_allocated_rect(
      ::ether::draw::Rect* rect);
  ::ether::draw::Rect* unsafe_arena_release_rect();

  // .ether.draw.Circle circle = 8;
  bool has_circle() const;
  private:
  bool _internal_has_circle() const;
  public:
  void clear_circle();
  const ::ether::draw::Circle& circle() const;
  PROTOBUF_NODISCARD ::ether::draw::Circle* release_circle();
  ::ether::draw::Circle* mutable_circle();
  void set_allocated_circle(::ether::draw::Circle* circle);
  private:
  const ::ether::draw::Circle& _internal_circle() const;
  ::ether::draw::Circle* _internal_mutable_circle();
  public:
  void unsafe_arena_set_allocated_circle(
      ::ether::draw::Circle* circle);
  ::ether::draw::Circle* unsafe_arena_release_circle();

  void clear_object();
  ObjectCase object_case() const;
  // @@protoc_insertion_point(class_scope:ether.draw.DrawObject)
 private:
  class _Internal;
  void set_has_robot_yel();
  void set_has_robot_blu();
  void set_has_ball();
  void set_has_line();
  void set_has_arrow();
  void set_has_polygon();
  void set_has_rect();
  void set_has_circle();

  inline bool has_object() const;
  inline void clear_has_object();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union ObjectUnion {
      constexpr ObjectUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::ether::draw::RobotYel* robot_yel_;
      ::ether::draw::RobotBlu* robot_blu_;
      ::ether::draw::Ball* ball_;
      ::ether::draw::Line* line_;
      ::ether::draw::Arrow* arrow_;
      ::ether::draw::Polygon* polygon_;
      ::ether::draw::Rect* rect_;
      ::ether::draw::Circle* circle_;
    } object_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ether_2fdraw_2eproto;
};
// -------------------------------------------------------------------

class RobotYel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ether.draw.RobotYel) */ {
 public:
  inline RobotYel() : RobotYel(nullptr) {}
  ~RobotYel() override;
  explicit PROTOBUF_CONSTEXPR RobotYel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotYel(const RobotYel& from);
  RobotYel(RobotYel&& from) noexcept
    : RobotYel() {
    *this = ::std::move(from);
  }

  inline RobotYel& operator=(const RobotYel& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotYel& operator=(RobotYel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotYel& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotYel* internal_default_instance() {
    return reinterpret_cast<const RobotYel*>(
               &_RobotYel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RobotYel& a, RobotYel& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotYel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotYel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotYel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotYel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotYel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RobotYel& from) {
    RobotYel::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotYel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ether.draw.RobotYel";
  }
  protected:
  explicit RobotYel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kRotationFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float rotation = 3;
  void clear_rotation();
  float rotation() const;
  void set_rotation(float value);
  private:
  float _internal_rotation() const;
  void _internal_set_rotation(float value);
  public:

  // @@protoc_insertion_point(class_scope:ether.draw.RobotYel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float rotation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ether_2fdraw_2eproto;
};
// -------------------------------------------------------------------

class RobotBlu final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ether.draw.RobotBlu) */ {
 public:
  inline RobotBlu() : RobotBlu(nullptr) {}
  ~RobotBlu() override;
  explicit PROTOBUF_CONSTEXPR RobotBlu(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RobotBlu(const RobotBlu& from);
  RobotBlu(RobotBlu&& from) noexcept
    : RobotBlu() {
    *this = ::std::move(from);
  }

  inline RobotBlu& operator=(const RobotBlu& from) {
    CopyFrom(from);
    return *this;
  }
  inline RobotBlu& operator=(RobotBlu&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RobotBlu& default_instance() {
    return *internal_default_instance();
  }
  static inline const RobotBlu* internal_default_instance() {
    return reinterpret_cast<const RobotBlu*>(
               &_RobotBlu_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RobotBlu& a, RobotBlu& b) {
    a.Swap(&b);
  }
  inline void Swap(RobotBlu* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RobotBlu* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RobotBlu* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RobotBlu>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RobotBlu& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RobotBlu& from) {
    RobotBlu::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RobotBlu* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ether.draw.RobotBlu";
  }
  protected:
  explicit RobotBlu(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kRotationFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float rotation = 3;
  void clear_rotation();
  float rotation() const;
  void set_rotation(float value);
  private:
  float _internal_rotation() const;
  void _internal_set_rotation(float value);
  public:

  // @@protoc_insertion_point(class_scope:ether.draw.RobotBlu)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    float rotation_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ether_2fdraw_2eproto;
};
// -------------------------------------------------------------------

class Ball final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ether.draw.Ball) */ {
 public:
  inline Ball() : Ball(nullptr) {}
  ~Ball() override;
  explicit PROTOBUF_CONSTEXPR Ball(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Ball(const Ball& from);
  Ball(Ball&& from) noexcept
    : Ball() {
    *this = ::std::move(from);
  }

  inline Ball& operator=(const Ball& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ball& operator=(Ball&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Ball& default_instance() {
    return *internal_default_instance();
  }
  static inline const Ball* internal_default_instance() {
    return reinterpret_cast<const Ball*>(
               &_Ball_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Ball& a, Ball& b) {
    a.Swap(&b);
  }
  inline void Swap(Ball* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ball* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Ball* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Ball>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Ball& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Ball& from) {
    Ball::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ball* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ether.draw.Ball";
  }
  protected:
  explicit Ball(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // @@protoc_insertion_point(class_scope:ether.draw.Ball)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float x_;
    float y_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ether_2fdraw_2eproto;
};
// -------------------------------------------------------------------

class Line final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ether.draw.Line) */ {
 public:
  inline Line() : Line(nullptr) {}
  ~Line() override;
  explicit PROTOBUF_CONSTEXPR Line(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Line(const Line& from);
  Line(Line&& from) noexcept
    : Line() {
    *this = ::std::move(from);
  }

  inline Line& operator=(const Line& from) {
    CopyFrom(from);
    return *this;
  }
  inline Line& operator=(Line&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Line& default_instance() {
    return *internal_default_instance();
  }
  static inline const Line* internal_default_instance() {
    return reinterpret_cast<const Line*>(
               &_Line_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Line& a, Line& b) {
    a.Swap(&b);
  }
  inline void Swap(Line* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Line* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Line* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Line>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Line& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Line& from) {
    Line::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Line* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ether.draw.Line";
  }
  protected:
  explicit Line(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXListFieldNumber = 1,
    kYListFieldNumber = 2,
    kColorFieldNumber = 3,
    kWidthFieldNumber = 4,
  };
  // repeated float x_list = 1;
  int x_list_size() const;
  private:
  int _internal_x_list_size() const;
  public:
  void clear_x_list();
  private:
  float _internal_x_list(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_x_list() const;
  void _internal_add_x_list(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_x_list();
  public:
  float x_list(int index) const;
  void set_x_list(int index, float value);
  void add_x_list(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      x_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_x_list();

  // repeated float y_list = 2;
  int y_list_size() const;
  private:
  int _internal_y_list_size() const;
  public:
  void clear_y_list();
  private:
  float _internal_y_list(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_y_list() const;
  void _internal_add_y_list(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_y_list();
  public:
  float y_list(int index) const;
  void set_y_list(int index, float value);
  void add_y_list(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      y_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_y_list();

  // string color = 3;
  void clear_color();
  const std::string& color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* color);
  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(const std::string& value);
  std::string* _internal_mutable_color();
  public:

  // float width = 4;
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // @@protoc_insertion_point(class_scope:ether.draw.Line)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > x_list_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > y_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
    float width_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ether_2fdraw_2eproto;
};
// -------------------------------------------------------------------

class Arrow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ether.draw.Arrow) */ {
 public:
  inline Arrow() : Arrow(nullptr) {}
  ~Arrow() override;
  explicit PROTOBUF_CONSTEXPR Arrow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Arrow(const Arrow& from);
  Arrow(Arrow&& from) noexcept
    : Arrow() {
    *this = ::std::move(from);
  }

  inline Arrow& operator=(const Arrow& from) {
    CopyFrom(from);
    return *this;
  }
  inline Arrow& operator=(Arrow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Arrow& default_instance() {
    return *internal_default_instance();
  }
  static inline const Arrow* internal_default_instance() {
    return reinterpret_cast<const Arrow*>(
               &_Arrow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Arrow& a, Arrow& b) {
    a.Swap(&b);
  }
  inline void Swap(Arrow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Arrow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Arrow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Arrow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Arrow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Arrow& from) {
    Arrow::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Arrow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ether.draw.Arrow";
  }
  protected:
  explicit Arrow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 5,
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kDxFieldNumber = 3,
    kDyFieldNumber = 4,
    kWidthFieldNumber = 6,
  };
  // string color = 5;
  void clear_color();
  const std::string& color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* color);
  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(const std::string& value);
  std::string* _internal_mutable_color();
  public:

  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float dx = 3;
  void clear_dx();
  float dx() const;
  void set_dx(float value);
  private:
  float _internal_dx() const;
  void _internal_set_dx(float value);
  public:

  // float dy = 4;
  void clear_dy();
  float dy() const;
  void set_dy(float value);
  private:
  float _internal_dy() const;
  void _internal_set_dy(float value);
  public:

  // float width = 6;
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // @@protoc_insertion_point(class_scope:ether.draw.Arrow)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
    float x_;
    float y_;
    float dx_;
    float dy_;
    float width_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ether_2fdraw_2eproto;
};
// -------------------------------------------------------------------

class Polygon final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ether.draw.Polygon) */ {
 public:
  inline Polygon() : Polygon(nullptr) {}
  ~Polygon() override;
  explicit PROTOBUF_CONSTEXPR Polygon(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Polygon(const Polygon& from);
  Polygon(Polygon&& from) noexcept
    : Polygon() {
    *this = ::std::move(from);
  }

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }
  inline Polygon& operator=(Polygon&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Polygon& default_instance() {
    return *internal_default_instance();
  }
  static inline const Polygon* internal_default_instance() {
    return reinterpret_cast<const Polygon*>(
               &_Polygon_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Polygon& a, Polygon& b) {
    a.Swap(&b);
  }
  inline void Swap(Polygon* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Polygon* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Polygon* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Polygon>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Polygon& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Polygon& from) {
    Polygon::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Polygon* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ether.draw.Polygon";
  }
  protected:
  explicit Polygon(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXListFieldNumber = 1,
    kYListFieldNumber = 2,
    kColorFieldNumber = 3,
    kWidthFieldNumber = 4,
  };
  // repeated float x_list = 1;
  int x_list_size() const;
  private:
  int _internal_x_list_size() const;
  public:
  void clear_x_list();
  private:
  float _internal_x_list(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_x_list() const;
  void _internal_add_x_list(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_x_list();
  public:
  float x_list(int index) const;
  void set_x_list(int index, float value);
  void add_x_list(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      x_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_x_list();

  // repeated float y_list = 2;
  int y_list_size() const;
  private:
  int _internal_y_list_size() const;
  public:
  void clear_y_list();
  private:
  float _internal_y_list(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_y_list() const;
  void _internal_add_y_list(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_y_list();
  public:
  float y_list(int index) const;
  void set_y_list(int index, float value);
  void add_y_list(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      y_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_y_list();

  // string color = 3;
  void clear_color();
  const std::string& color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* color);
  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(const std::string& value);
  std::string* _internal_mutable_color();
  public:

  // float width = 4;
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // @@protoc_insertion_point(class_scope:ether.draw.Polygon)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > x_list_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > y_list_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
    float width_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ether_2fdraw_2eproto;
};
// -------------------------------------------------------------------

class Rect final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ether.draw.Rect) */ {
 public:
  inline Rect() : Rect(nullptr) {}
  ~Rect() override;
  explicit PROTOBUF_CONSTEXPR Rect(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Rect(const Rect& from);
  Rect(Rect&& from) noexcept
    : Rect() {
    *this = ::std::move(from);
  }

  inline Rect& operator=(const Rect& from) {
    CopyFrom(from);
    return *this;
  }
  inline Rect& operator=(Rect&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Rect& default_instance() {
    return *internal_default_instance();
  }
  static inline const Rect* internal_default_instance() {
    return reinterpret_cast<const Rect*>(
               &_Rect_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Rect& a, Rect& b) {
    a.Swap(&b);
  }
  inline void Swap(Rect* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Rect* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Rect* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Rect>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Rect& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Rect& from) {
    Rect::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Rect* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ether.draw.Rect";
  }
  protected:
  explicit Rect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 5,
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kWidthFieldNumber = 3,
    kHeightFieldNumber = 4,
  };
  // string color = 5;
  void clear_color();
  const std::string& color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* color);
  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(const std::string& value);
  std::string* _internal_mutable_color();
  public:

  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float width = 3;
  void clear_width();
  float width() const;
  void set_width(float value);
  private:
  float _internal_width() const;
  void _internal_set_width(float value);
  public:

  // float height = 4;
  void clear_height();
  float height() const;
  void set_height(float value);
  private:
  float _internal_height() const;
  void _internal_set_height(float value);
  public:

  // @@protoc_insertion_point(class_scope:ether.draw.Rect)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
    float x_;
    float y_;
    float width_;
    float height_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ether_2fdraw_2eproto;
};
// -------------------------------------------------------------------

class Circle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ether.draw.Circle) */ {
 public:
  inline Circle() : Circle(nullptr) {}
  ~Circle() override;
  explicit PROTOBUF_CONSTEXPR Circle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Circle(const Circle& from);
  Circle(Circle&& from) noexcept
    : Circle() {
    *this = ::std::move(from);
  }

  inline Circle& operator=(const Circle& from) {
    CopyFrom(from);
    return *this;
  }
  inline Circle& operator=(Circle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Circle& default_instance() {
    return *internal_default_instance();
  }
  static inline const Circle* internal_default_instance() {
    return reinterpret_cast<const Circle*>(
               &_Circle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Circle& a, Circle& b) {
    a.Swap(&b);
  }
  inline void Swap(Circle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Circle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Circle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Circle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Circle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Circle& from) {
    Circle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Circle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ether.draw.Circle";
  }
  protected:
  explicit Circle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kColorFieldNumber = 4,
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kRadiusFieldNumber = 3,
  };
  // string color = 4;
  void clear_color();
  const std::string& color() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_color(ArgT0&& arg0, ArgT... args);
  std::string* mutable_color();
  PROTOBUF_NODISCARD std::string* release_color();
  void set_allocated_color(std::string* color);
  private:
  const std::string& _internal_color() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_color(const std::string& value);
  std::string* _internal_mutable_color();
  public:

  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float radius = 3;
  void clear_radius();
  float radius() const;
  void set_radius(float value);
  private:
  float _internal_radius() const;
  void _internal_set_radius(float value);
  public:

  // @@protoc_insertion_point(class_scope:ether.draw.Circle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr color_;
    float x_;
    float y_;
    float radius_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_ether_2fdraw_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// DrawCommand

// map<string, .ether.draw.Layer> layers = 1;
inline int DrawCommand::_internal_layers_size() const {
  return _impl_.layers_.size();
}
inline int DrawCommand::layers_size() const {
  return _internal_layers_size();
}
inline void DrawCommand::clear_layers() {
  _impl_.layers_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ether::draw::Layer >&
DrawCommand::_internal_layers() const {
  return _impl_.layers_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ether::draw::Layer >&
DrawCommand::layers() const {
  // @@protoc_insertion_point(field_map:ether.draw.DrawCommand.layers)
  return _internal_layers();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ether::draw::Layer >*
DrawCommand::_internal_mutable_layers() {
  return _impl_.layers_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ether::draw::Layer >*
DrawCommand::mutable_layers() {
  // @@protoc_insertion_point(field_mutable_map:ether.draw.DrawCommand.layers)
  return _internal_mutable_layers();
}

// -------------------------------------------------------------------

// Layer

// repeated .ether.draw.DrawObject data = 1;
inline int Layer::_internal_data_size() const {
  return _impl_.data_.size();
}
inline int Layer::data_size() const {
  return _internal_data_size();
}
inline void Layer::clear_data() {
  _impl_.data_.Clear();
}
inline ::ether::draw::DrawObject* Layer::mutable_data(int index) {
  // @@protoc_insertion_point(field_mutable:ether.draw.Layer.data)
  return _impl_.data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ether::draw::DrawObject >*
Layer::mutable_data() {
  // @@protoc_insertion_point(field_mutable_list:ether.draw.Layer.data)
  return &_impl_.data_;
}
inline const ::ether::draw::DrawObject& Layer::_internal_data(int index) const {
  return _impl_.data_.Get(index);
}
inline const ::ether::draw::DrawObject& Layer::data(int index) const {
  // @@protoc_insertion_point(field_get:ether.draw.Layer.data)
  return _internal_data(index);
}
inline ::ether::draw::DrawObject* Layer::_internal_add_data() {
  return _impl_.data_.Add();
}
inline ::ether::draw::DrawObject* Layer::add_data() {
  ::ether::draw::DrawObject* _add = _internal_add_data();
  // @@protoc_insertion_point(field_add:ether.draw.Layer.data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ether::draw::DrawObject >&
Layer::data() const {
  // @@protoc_insertion_point(field_list:ether.draw.Layer.data)
  return _impl_.data_;
}

// bool is_visible = 2;
inline void Layer::clear_is_visible() {
  _impl_.is_visible_ = false;
}
inline bool Layer::_internal_is_visible() const {
  return _impl_.is_visible_;
}
inline bool Layer::is_visible() const {
  // @@protoc_insertion_point(field_get:ether.draw.Layer.is_visible)
  return _internal_is_visible();
}
inline void Layer::_internal_set_is_visible(bool value) {
  
  _impl_.is_visible_ = value;
}
inline void Layer::set_is_visible(bool value) {
  _internal_set_is_visible(value);
  // @@protoc_insertion_point(field_set:ether.draw.Layer.is_visible)
}

// -------------------------------------------------------------------

// DrawObject

// .ether.draw.RobotYel robot_yel = 1;
inline bool DrawObject::_internal_has_robot_yel() const {
  return object_case() == kRobotYel;
}
inline bool DrawObject::has_robot_yel() const {
  return _internal_has_robot_yel();
}
inline void DrawObject::set_has_robot_yel() {
  _impl_._oneof_case_[0] = kRobotYel;
}
inline void DrawObject::clear_robot_yel() {
  if (_internal_has_robot_yel()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.object_.robot_yel_;
    }
    clear_has_object();
  }
}
inline ::ether::draw::RobotYel* DrawObject::release_robot_yel() {
  // @@protoc_insertion_point(field_release:ether.draw.DrawObject.robot_yel)
  if (_internal_has_robot_yel()) {
    clear_has_object();
    ::ether::draw::RobotYel* temp = _impl_.object_.robot_yel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.object_.robot_yel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ether::draw::RobotYel& DrawObject::_internal_robot_yel() const {
  return _internal_has_robot_yel()
      ? *_impl_.object_.robot_yel_
      : reinterpret_cast< ::ether::draw::RobotYel&>(::ether::draw::_RobotYel_default_instance_);
}
inline const ::ether::draw::RobotYel& DrawObject::robot_yel() const {
  // @@protoc_insertion_point(field_get:ether.draw.DrawObject.robot_yel)
  return _internal_robot_yel();
}
inline ::ether::draw::RobotYel* DrawObject::unsafe_arena_release_robot_yel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ether.draw.DrawObject.robot_yel)
  if (_internal_has_robot_yel()) {
    clear_has_object();
    ::ether::draw::RobotYel* temp = _impl_.object_.robot_yel_;
    _impl_.object_.robot_yel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawObject::unsafe_arena_set_allocated_robot_yel(::ether::draw::RobotYel* robot_yel) {
  clear_object();
  if (robot_yel) {
    set_has_robot_yel();
    _impl_.object_.robot_yel_ = robot_yel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ether.draw.DrawObject.robot_yel)
}
inline ::ether::draw::RobotYel* DrawObject::_internal_mutable_robot_yel() {
  if (!_internal_has_robot_yel()) {
    clear_object();
    set_has_robot_yel();
    _impl_.object_.robot_yel_ = CreateMaybeMessage< ::ether::draw::RobotYel >(GetArenaForAllocation());
  }
  return _impl_.object_.robot_yel_;
}
inline ::ether::draw::RobotYel* DrawObject::mutable_robot_yel() {
  ::ether::draw::RobotYel* _msg = _internal_mutable_robot_yel();
  // @@protoc_insertion_point(field_mutable:ether.draw.DrawObject.robot_yel)
  return _msg;
}

// .ether.draw.RobotBlu robot_blu = 2;
inline bool DrawObject::_internal_has_robot_blu() const {
  return object_case() == kRobotBlu;
}
inline bool DrawObject::has_robot_blu() const {
  return _internal_has_robot_blu();
}
inline void DrawObject::set_has_robot_blu() {
  _impl_._oneof_case_[0] = kRobotBlu;
}
inline void DrawObject::clear_robot_blu() {
  if (_internal_has_robot_blu()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.object_.robot_blu_;
    }
    clear_has_object();
  }
}
inline ::ether::draw::RobotBlu* DrawObject::release_robot_blu() {
  // @@protoc_insertion_point(field_release:ether.draw.DrawObject.robot_blu)
  if (_internal_has_robot_blu()) {
    clear_has_object();
    ::ether::draw::RobotBlu* temp = _impl_.object_.robot_blu_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.object_.robot_blu_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ether::draw::RobotBlu& DrawObject::_internal_robot_blu() const {
  return _internal_has_robot_blu()
      ? *_impl_.object_.robot_blu_
      : reinterpret_cast< ::ether::draw::RobotBlu&>(::ether::draw::_RobotBlu_default_instance_);
}
inline const ::ether::draw::RobotBlu& DrawObject::robot_blu() const {
  // @@protoc_insertion_point(field_get:ether.draw.DrawObject.robot_blu)
  return _internal_robot_blu();
}
inline ::ether::draw::RobotBlu* DrawObject::unsafe_arena_release_robot_blu() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ether.draw.DrawObject.robot_blu)
  if (_internal_has_robot_blu()) {
    clear_has_object();
    ::ether::draw::RobotBlu* temp = _impl_.object_.robot_blu_;
    _impl_.object_.robot_blu_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawObject::unsafe_arena_set_allocated_robot_blu(::ether::draw::RobotBlu* robot_blu) {
  clear_object();
  if (robot_blu) {
    set_has_robot_blu();
    _impl_.object_.robot_blu_ = robot_blu;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ether.draw.DrawObject.robot_blu)
}
inline ::ether::draw::RobotBlu* DrawObject::_internal_mutable_robot_blu() {
  if (!_internal_has_robot_blu()) {
    clear_object();
    set_has_robot_blu();
    _impl_.object_.robot_blu_ = CreateMaybeMessage< ::ether::draw::RobotBlu >(GetArenaForAllocation());
  }
  return _impl_.object_.robot_blu_;
}
inline ::ether::draw::RobotBlu* DrawObject::mutable_robot_blu() {
  ::ether::draw::RobotBlu* _msg = _internal_mutable_robot_blu();
  // @@protoc_insertion_point(field_mutable:ether.draw.DrawObject.robot_blu)
  return _msg;
}

// .ether.draw.Ball ball = 3;
inline bool DrawObject::_internal_has_ball() const {
  return object_case() == kBall;
}
inline bool DrawObject::has_ball() const {
  return _internal_has_ball();
}
inline void DrawObject::set_has_ball() {
  _impl_._oneof_case_[0] = kBall;
}
inline void DrawObject::clear_ball() {
  if (_internal_has_ball()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.object_.ball_;
    }
    clear_has_object();
  }
}
inline ::ether::draw::Ball* DrawObject::release_ball() {
  // @@protoc_insertion_point(field_release:ether.draw.DrawObject.ball)
  if (_internal_has_ball()) {
    clear_has_object();
    ::ether::draw::Ball* temp = _impl_.object_.ball_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.object_.ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ether::draw::Ball& DrawObject::_internal_ball() const {
  return _internal_has_ball()
      ? *_impl_.object_.ball_
      : reinterpret_cast< ::ether::draw::Ball&>(::ether::draw::_Ball_default_instance_);
}
inline const ::ether::draw::Ball& DrawObject::ball() const {
  // @@protoc_insertion_point(field_get:ether.draw.DrawObject.ball)
  return _internal_ball();
}
inline ::ether::draw::Ball* DrawObject::unsafe_arena_release_ball() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ether.draw.DrawObject.ball)
  if (_internal_has_ball()) {
    clear_has_object();
    ::ether::draw::Ball* temp = _impl_.object_.ball_;
    _impl_.object_.ball_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawObject::unsafe_arena_set_allocated_ball(::ether::draw::Ball* ball) {
  clear_object();
  if (ball) {
    set_has_ball();
    _impl_.object_.ball_ = ball;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ether.draw.DrawObject.ball)
}
inline ::ether::draw::Ball* DrawObject::_internal_mutable_ball() {
  if (!_internal_has_ball()) {
    clear_object();
    set_has_ball();
    _impl_.object_.ball_ = CreateMaybeMessage< ::ether::draw::Ball >(GetArenaForAllocation());
  }
  return _impl_.object_.ball_;
}
inline ::ether::draw::Ball* DrawObject::mutable_ball() {
  ::ether::draw::Ball* _msg = _internal_mutable_ball();
  // @@protoc_insertion_point(field_mutable:ether.draw.DrawObject.ball)
  return _msg;
}

// .ether.draw.Line line = 4;
inline bool DrawObject::_internal_has_line() const {
  return object_case() == kLine;
}
inline bool DrawObject::has_line() const {
  return _internal_has_line();
}
inline void DrawObject::set_has_line() {
  _impl_._oneof_case_[0] = kLine;
}
inline void DrawObject::clear_line() {
  if (_internal_has_line()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.object_.line_;
    }
    clear_has_object();
  }
}
inline ::ether::draw::Line* DrawObject::release_line() {
  // @@protoc_insertion_point(field_release:ether.draw.DrawObject.line)
  if (_internal_has_line()) {
    clear_has_object();
    ::ether::draw::Line* temp = _impl_.object_.line_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.object_.line_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ether::draw::Line& DrawObject::_internal_line() const {
  return _internal_has_line()
      ? *_impl_.object_.line_
      : reinterpret_cast< ::ether::draw::Line&>(::ether::draw::_Line_default_instance_);
}
inline const ::ether::draw::Line& DrawObject::line() const {
  // @@protoc_insertion_point(field_get:ether.draw.DrawObject.line)
  return _internal_line();
}
inline ::ether::draw::Line* DrawObject::unsafe_arena_release_line() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ether.draw.DrawObject.line)
  if (_internal_has_line()) {
    clear_has_object();
    ::ether::draw::Line* temp = _impl_.object_.line_;
    _impl_.object_.line_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawObject::unsafe_arena_set_allocated_line(::ether::draw::Line* line) {
  clear_object();
  if (line) {
    set_has_line();
    _impl_.object_.line_ = line;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ether.draw.DrawObject.line)
}
inline ::ether::draw::Line* DrawObject::_internal_mutable_line() {
  if (!_internal_has_line()) {
    clear_object();
    set_has_line();
    _impl_.object_.line_ = CreateMaybeMessage< ::ether::draw::Line >(GetArenaForAllocation());
  }
  return _impl_.object_.line_;
}
inline ::ether::draw::Line* DrawObject::mutable_line() {
  ::ether::draw::Line* _msg = _internal_mutable_line();
  // @@protoc_insertion_point(field_mutable:ether.draw.DrawObject.line)
  return _msg;
}

// .ether.draw.Arrow arrow = 5;
inline bool DrawObject::_internal_has_arrow() const {
  return object_case() == kArrow;
}
inline bool DrawObject::has_arrow() const {
  return _internal_has_arrow();
}
inline void DrawObject::set_has_arrow() {
  _impl_._oneof_case_[0] = kArrow;
}
inline void DrawObject::clear_arrow() {
  if (_internal_has_arrow()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.object_.arrow_;
    }
    clear_has_object();
  }
}
inline ::ether::draw::Arrow* DrawObject::release_arrow() {
  // @@protoc_insertion_point(field_release:ether.draw.DrawObject.arrow)
  if (_internal_has_arrow()) {
    clear_has_object();
    ::ether::draw::Arrow* temp = _impl_.object_.arrow_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.object_.arrow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ether::draw::Arrow& DrawObject::_internal_arrow() const {
  return _internal_has_arrow()
      ? *_impl_.object_.arrow_
      : reinterpret_cast< ::ether::draw::Arrow&>(::ether::draw::_Arrow_default_instance_);
}
inline const ::ether::draw::Arrow& DrawObject::arrow() const {
  // @@protoc_insertion_point(field_get:ether.draw.DrawObject.arrow)
  return _internal_arrow();
}
inline ::ether::draw::Arrow* DrawObject::unsafe_arena_release_arrow() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ether.draw.DrawObject.arrow)
  if (_internal_has_arrow()) {
    clear_has_object();
    ::ether::draw::Arrow* temp = _impl_.object_.arrow_;
    _impl_.object_.arrow_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawObject::unsafe_arena_set_allocated_arrow(::ether::draw::Arrow* arrow) {
  clear_object();
  if (arrow) {
    set_has_arrow();
    _impl_.object_.arrow_ = arrow;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ether.draw.DrawObject.arrow)
}
inline ::ether::draw::Arrow* DrawObject::_internal_mutable_arrow() {
  if (!_internal_has_arrow()) {
    clear_object();
    set_has_arrow();
    _impl_.object_.arrow_ = CreateMaybeMessage< ::ether::draw::Arrow >(GetArenaForAllocation());
  }
  return _impl_.object_.arrow_;
}
inline ::ether::draw::Arrow* DrawObject::mutable_arrow() {
  ::ether::draw::Arrow* _msg = _internal_mutable_arrow();
  // @@protoc_insertion_point(field_mutable:ether.draw.DrawObject.arrow)
  return _msg;
}

// .ether.draw.Polygon polygon = 6;
inline bool DrawObject::_internal_has_polygon() const {
  return object_case() == kPolygon;
}
inline bool DrawObject::has_polygon() const {
  return _internal_has_polygon();
}
inline void DrawObject::set_has_polygon() {
  _impl_._oneof_case_[0] = kPolygon;
}
inline void DrawObject::clear_polygon() {
  if (_internal_has_polygon()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.object_.polygon_;
    }
    clear_has_object();
  }
}
inline ::ether::draw::Polygon* DrawObject::release_polygon() {
  // @@protoc_insertion_point(field_release:ether.draw.DrawObject.polygon)
  if (_internal_has_polygon()) {
    clear_has_object();
    ::ether::draw::Polygon* temp = _impl_.object_.polygon_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.object_.polygon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ether::draw::Polygon& DrawObject::_internal_polygon() const {
  return _internal_has_polygon()
      ? *_impl_.object_.polygon_
      : reinterpret_cast< ::ether::draw::Polygon&>(::ether::draw::_Polygon_default_instance_);
}
inline const ::ether::draw::Polygon& DrawObject::polygon() const {
  // @@protoc_insertion_point(field_get:ether.draw.DrawObject.polygon)
  return _internal_polygon();
}
inline ::ether::draw::Polygon* DrawObject::unsafe_arena_release_polygon() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ether.draw.DrawObject.polygon)
  if (_internal_has_polygon()) {
    clear_has_object();
    ::ether::draw::Polygon* temp = _impl_.object_.polygon_;
    _impl_.object_.polygon_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawObject::unsafe_arena_set_allocated_polygon(::ether::draw::Polygon* polygon) {
  clear_object();
  if (polygon) {
    set_has_polygon();
    _impl_.object_.polygon_ = polygon;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ether.draw.DrawObject.polygon)
}
inline ::ether::draw::Polygon* DrawObject::_internal_mutable_polygon() {
  if (!_internal_has_polygon()) {
    clear_object();
    set_has_polygon();
    _impl_.object_.polygon_ = CreateMaybeMessage< ::ether::draw::Polygon >(GetArenaForAllocation());
  }
  return _impl_.object_.polygon_;
}
inline ::ether::draw::Polygon* DrawObject::mutable_polygon() {
  ::ether::draw::Polygon* _msg = _internal_mutable_polygon();
  // @@protoc_insertion_point(field_mutable:ether.draw.DrawObject.polygon)
  return _msg;
}

// .ether.draw.Rect rect = 7;
inline bool DrawObject::_internal_has_rect() const {
  return object_case() == kRect;
}
inline bool DrawObject::has_rect() const {
  return _internal_has_rect();
}
inline void DrawObject::set_has_rect() {
  _impl_._oneof_case_[0] = kRect;
}
inline void DrawObject::clear_rect() {
  if (_internal_has_rect()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.object_.rect_;
    }
    clear_has_object();
  }
}
inline ::ether::draw::Rect* DrawObject::release_rect() {
  // @@protoc_insertion_point(field_release:ether.draw.DrawObject.rect)
  if (_internal_has_rect()) {
    clear_has_object();
    ::ether::draw::Rect* temp = _impl_.object_.rect_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.object_.rect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ether::draw::Rect& DrawObject::_internal_rect() const {
  return _internal_has_rect()
      ? *_impl_.object_.rect_
      : reinterpret_cast< ::ether::draw::Rect&>(::ether::draw::_Rect_default_instance_);
}
inline const ::ether::draw::Rect& DrawObject::rect() const {
  // @@protoc_insertion_point(field_get:ether.draw.DrawObject.rect)
  return _internal_rect();
}
inline ::ether::draw::Rect* DrawObject::unsafe_arena_release_rect() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ether.draw.DrawObject.rect)
  if (_internal_has_rect()) {
    clear_has_object();
    ::ether::draw::Rect* temp = _impl_.object_.rect_;
    _impl_.object_.rect_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawObject::unsafe_arena_set_allocated_rect(::ether::draw::Rect* rect) {
  clear_object();
  if (rect) {
    set_has_rect();
    _impl_.object_.rect_ = rect;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ether.draw.DrawObject.rect)
}
inline ::ether::draw::Rect* DrawObject::_internal_mutable_rect() {
  if (!_internal_has_rect()) {
    clear_object();
    set_has_rect();
    _impl_.object_.rect_ = CreateMaybeMessage< ::ether::draw::Rect >(GetArenaForAllocation());
  }
  return _impl_.object_.rect_;
}
inline ::ether::draw::Rect* DrawObject::mutable_rect() {
  ::ether::draw::Rect* _msg = _internal_mutable_rect();
  // @@protoc_insertion_point(field_mutable:ether.draw.DrawObject.rect)
  return _msg;
}

// .ether.draw.Circle circle = 8;
inline bool DrawObject::_internal_has_circle() const {
  return object_case() == kCircle;
}
inline bool DrawObject::has_circle() const {
  return _internal_has_circle();
}
inline void DrawObject::set_has_circle() {
  _impl_._oneof_case_[0] = kCircle;
}
inline void DrawObject::clear_circle() {
  if (_internal_has_circle()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.object_.circle_;
    }
    clear_has_object();
  }
}
inline ::ether::draw::Circle* DrawObject::release_circle() {
  // @@protoc_insertion_point(field_release:ether.draw.DrawObject.circle)
  if (_internal_has_circle()) {
    clear_has_object();
    ::ether::draw::Circle* temp = _impl_.object_.circle_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.object_.circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::ether::draw::Circle& DrawObject::_internal_circle() const {
  return _internal_has_circle()
      ? *_impl_.object_.circle_
      : reinterpret_cast< ::ether::draw::Circle&>(::ether::draw::_Circle_default_instance_);
}
inline const ::ether::draw::Circle& DrawObject::circle() const {
  // @@protoc_insertion_point(field_get:ether.draw.DrawObject.circle)
  return _internal_circle();
}
inline ::ether::draw::Circle* DrawObject::unsafe_arena_release_circle() {
  // @@protoc_insertion_point(field_unsafe_arena_release:ether.draw.DrawObject.circle)
  if (_internal_has_circle()) {
    clear_has_object();
    ::ether::draw::Circle* temp = _impl_.object_.circle_;
    _impl_.object_.circle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DrawObject::unsafe_arena_set_allocated_circle(::ether::draw::Circle* circle) {
  clear_object();
  if (circle) {
    set_has_circle();
    _impl_.object_.circle_ = circle;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ether.draw.DrawObject.circle)
}
inline ::ether::draw::Circle* DrawObject::_internal_mutable_circle() {
  if (!_internal_has_circle()) {
    clear_object();
    set_has_circle();
    _impl_.object_.circle_ = CreateMaybeMessage< ::ether::draw::Circle >(GetArenaForAllocation());
  }
  return _impl_.object_.circle_;
}
inline ::ether::draw::Circle* DrawObject::mutable_circle() {
  ::ether::draw::Circle* _msg = _internal_mutable_circle();
  // @@protoc_insertion_point(field_mutable:ether.draw.DrawObject.circle)
  return _msg;
}

inline bool DrawObject::has_object() const {
  return object_case() != OBJECT_NOT_SET;
}
inline void DrawObject::clear_has_object() {
  _impl_._oneof_case_[0] = OBJECT_NOT_SET;
}
inline DrawObject::ObjectCase DrawObject::object_case() const {
  return DrawObject::ObjectCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RobotYel

// float x = 1;
inline void RobotYel::clear_x() {
  _impl_.x_ = 0;
}
inline float RobotYel::_internal_x() const {
  return _impl_.x_;
}
inline float RobotYel::x() const {
  // @@protoc_insertion_point(field_get:ether.draw.RobotYel.x)
  return _internal_x();
}
inline void RobotYel::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void RobotYel::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:ether.draw.RobotYel.x)
}

// float y = 2;
inline void RobotYel::clear_y() {
  _impl_.y_ = 0;
}
inline float RobotYel::_internal_y() const {
  return _impl_.y_;
}
inline float RobotYel::y() const {
  // @@protoc_insertion_point(field_get:ether.draw.RobotYel.y)
  return _internal_y();
}
inline void RobotYel::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void RobotYel::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:ether.draw.RobotYel.y)
}

// float rotation = 3;
inline void RobotYel::clear_rotation() {
  _impl_.rotation_ = 0;
}
inline float RobotYel::_internal_rotation() const {
  return _impl_.rotation_;
}
inline float RobotYel::rotation() const {
  // @@protoc_insertion_point(field_get:ether.draw.RobotYel.rotation)
  return _internal_rotation();
}
inline void RobotYel::_internal_set_rotation(float value) {
  
  _impl_.rotation_ = value;
}
inline void RobotYel::set_rotation(float value) {
  _internal_set_rotation(value);
  // @@protoc_insertion_point(field_set:ether.draw.RobotYel.rotation)
}

// -------------------------------------------------------------------

// RobotBlu

// float x = 1;
inline void RobotBlu::clear_x() {
  _impl_.x_ = 0;
}
inline float RobotBlu::_internal_x() const {
  return _impl_.x_;
}
inline float RobotBlu::x() const {
  // @@protoc_insertion_point(field_get:ether.draw.RobotBlu.x)
  return _internal_x();
}
inline void RobotBlu::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void RobotBlu::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:ether.draw.RobotBlu.x)
}

// float y = 2;
inline void RobotBlu::clear_y() {
  _impl_.y_ = 0;
}
inline float RobotBlu::_internal_y() const {
  return _impl_.y_;
}
inline float RobotBlu::y() const {
  // @@protoc_insertion_point(field_get:ether.draw.RobotBlu.y)
  return _internal_y();
}
inline void RobotBlu::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void RobotBlu::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:ether.draw.RobotBlu.y)
}

// float rotation = 3;
inline void RobotBlu::clear_rotation() {
  _impl_.rotation_ = 0;
}
inline float RobotBlu::_internal_rotation() const {
  return _impl_.rotation_;
}
inline float RobotBlu::rotation() const {
  // @@protoc_insertion_point(field_get:ether.draw.RobotBlu.rotation)
  return _internal_rotation();
}
inline void RobotBlu::_internal_set_rotation(float value) {
  
  _impl_.rotation_ = value;
}
inline void RobotBlu::set_rotation(float value) {
  _internal_set_rotation(value);
  // @@protoc_insertion_point(field_set:ether.draw.RobotBlu.rotation)
}

// -------------------------------------------------------------------

// Ball

// float x = 1;
inline void Ball::clear_x() {
  _impl_.x_ = 0;
}
inline float Ball::_internal_x() const {
  return _impl_.x_;
}
inline float Ball::x() const {
  // @@protoc_insertion_point(field_get:ether.draw.Ball.x)
  return _internal_x();
}
inline void Ball::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Ball::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:ether.draw.Ball.x)
}

// float y = 2;
inline void Ball::clear_y() {
  _impl_.y_ = 0;
}
inline float Ball::_internal_y() const {
  return _impl_.y_;
}
inline float Ball::y() const {
  // @@protoc_insertion_point(field_get:ether.draw.Ball.y)
  return _internal_y();
}
inline void Ball::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Ball::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:ether.draw.Ball.y)
}

// -------------------------------------------------------------------

// Line

// repeated float x_list = 1;
inline int Line::_internal_x_list_size() const {
  return _impl_.x_list_.size();
}
inline int Line::x_list_size() const {
  return _internal_x_list_size();
}
inline void Line::clear_x_list() {
  _impl_.x_list_.Clear();
}
inline float Line::_internal_x_list(int index) const {
  return _impl_.x_list_.Get(index);
}
inline float Line::x_list(int index) const {
  // @@protoc_insertion_point(field_get:ether.draw.Line.x_list)
  return _internal_x_list(index);
}
inline void Line::set_x_list(int index, float value) {
  _impl_.x_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:ether.draw.Line.x_list)
}
inline void Line::_internal_add_x_list(float value) {
  _impl_.x_list_.Add(value);
}
inline void Line::add_x_list(float value) {
  _internal_add_x_list(value);
  // @@protoc_insertion_point(field_add:ether.draw.Line.x_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Line::_internal_x_list() const {
  return _impl_.x_list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Line::x_list() const {
  // @@protoc_insertion_point(field_list:ether.draw.Line.x_list)
  return _internal_x_list();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Line::_internal_mutable_x_list() {
  return &_impl_.x_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Line::mutable_x_list() {
  // @@protoc_insertion_point(field_mutable_list:ether.draw.Line.x_list)
  return _internal_mutable_x_list();
}

// repeated float y_list = 2;
inline int Line::_internal_y_list_size() const {
  return _impl_.y_list_.size();
}
inline int Line::y_list_size() const {
  return _internal_y_list_size();
}
inline void Line::clear_y_list() {
  _impl_.y_list_.Clear();
}
inline float Line::_internal_y_list(int index) const {
  return _impl_.y_list_.Get(index);
}
inline float Line::y_list(int index) const {
  // @@protoc_insertion_point(field_get:ether.draw.Line.y_list)
  return _internal_y_list(index);
}
inline void Line::set_y_list(int index, float value) {
  _impl_.y_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:ether.draw.Line.y_list)
}
inline void Line::_internal_add_y_list(float value) {
  _impl_.y_list_.Add(value);
}
inline void Line::add_y_list(float value) {
  _internal_add_y_list(value);
  // @@protoc_insertion_point(field_add:ether.draw.Line.y_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Line::_internal_y_list() const {
  return _impl_.y_list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Line::y_list() const {
  // @@protoc_insertion_point(field_list:ether.draw.Line.y_list)
  return _internal_y_list();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Line::_internal_mutable_y_list() {
  return &_impl_.y_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Line::mutable_y_list() {
  // @@protoc_insertion_point(field_mutable_list:ether.draw.Line.y_list)
  return _internal_mutable_y_list();
}

// string color = 3;
inline void Line::clear_color() {
  _impl_.color_.ClearToEmpty();
}
inline const std::string& Line::color() const {
  // @@protoc_insertion_point(field_get:ether.draw.Line.color)
  return _internal_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Line::set_color(ArgT0&& arg0, ArgT... args) {
 
 _impl_.color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ether.draw.Line.color)
}
inline std::string* Line::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:ether.draw.Line.color)
  return _s;
}
inline const std::string& Line::_internal_color() const {
  return _impl_.color_.Get();
}
inline void Line::_internal_set_color(const std::string& value) {
  
  _impl_.color_.Set(value, GetArenaForAllocation());
}
inline std::string* Line::_internal_mutable_color() {
  
  return _impl_.color_.Mutable(GetArenaForAllocation());
}
inline std::string* Line::release_color() {
  // @@protoc_insertion_point(field_release:ether.draw.Line.color)
  return _impl_.color_.Release();
}
inline void Line::set_allocated_color(std::string* color) {
  if (color != nullptr) {
    
  } else {
    
  }
  _impl_.color_.SetAllocated(color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.color_.IsDefault()) {
    _impl_.color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ether.draw.Line.color)
}

// float width = 4;
inline void Line::clear_width() {
  _impl_.width_ = 0;
}
inline float Line::_internal_width() const {
  return _impl_.width_;
}
inline float Line::width() const {
  // @@protoc_insertion_point(field_get:ether.draw.Line.width)
  return _internal_width();
}
inline void Line::_internal_set_width(float value) {
  
  _impl_.width_ = value;
}
inline void Line::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:ether.draw.Line.width)
}

// -------------------------------------------------------------------

// Arrow

// float x = 1;
inline void Arrow::clear_x() {
  _impl_.x_ = 0;
}
inline float Arrow::_internal_x() const {
  return _impl_.x_;
}
inline float Arrow::x() const {
  // @@protoc_insertion_point(field_get:ether.draw.Arrow.x)
  return _internal_x();
}
inline void Arrow::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Arrow::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:ether.draw.Arrow.x)
}

// float y = 2;
inline void Arrow::clear_y() {
  _impl_.y_ = 0;
}
inline float Arrow::_internal_y() const {
  return _impl_.y_;
}
inline float Arrow::y() const {
  // @@protoc_insertion_point(field_get:ether.draw.Arrow.y)
  return _internal_y();
}
inline void Arrow::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Arrow::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:ether.draw.Arrow.y)
}

// float dx = 3;
inline void Arrow::clear_dx() {
  _impl_.dx_ = 0;
}
inline float Arrow::_internal_dx() const {
  return _impl_.dx_;
}
inline float Arrow::dx() const {
  // @@protoc_insertion_point(field_get:ether.draw.Arrow.dx)
  return _internal_dx();
}
inline void Arrow::_internal_set_dx(float value) {
  
  _impl_.dx_ = value;
}
inline void Arrow::set_dx(float value) {
  _internal_set_dx(value);
  // @@protoc_insertion_point(field_set:ether.draw.Arrow.dx)
}

// float dy = 4;
inline void Arrow::clear_dy() {
  _impl_.dy_ = 0;
}
inline float Arrow::_internal_dy() const {
  return _impl_.dy_;
}
inline float Arrow::dy() const {
  // @@protoc_insertion_point(field_get:ether.draw.Arrow.dy)
  return _internal_dy();
}
inline void Arrow::_internal_set_dy(float value) {
  
  _impl_.dy_ = value;
}
inline void Arrow::set_dy(float value) {
  _internal_set_dy(value);
  // @@protoc_insertion_point(field_set:ether.draw.Arrow.dy)
}

// string color = 5;
inline void Arrow::clear_color() {
  _impl_.color_.ClearToEmpty();
}
inline const std::string& Arrow::color() const {
  // @@protoc_insertion_point(field_get:ether.draw.Arrow.color)
  return _internal_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Arrow::set_color(ArgT0&& arg0, ArgT... args) {
 
 _impl_.color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ether.draw.Arrow.color)
}
inline std::string* Arrow::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:ether.draw.Arrow.color)
  return _s;
}
inline const std::string& Arrow::_internal_color() const {
  return _impl_.color_.Get();
}
inline void Arrow::_internal_set_color(const std::string& value) {
  
  _impl_.color_.Set(value, GetArenaForAllocation());
}
inline std::string* Arrow::_internal_mutable_color() {
  
  return _impl_.color_.Mutable(GetArenaForAllocation());
}
inline std::string* Arrow::release_color() {
  // @@protoc_insertion_point(field_release:ether.draw.Arrow.color)
  return _impl_.color_.Release();
}
inline void Arrow::set_allocated_color(std::string* color) {
  if (color != nullptr) {
    
  } else {
    
  }
  _impl_.color_.SetAllocated(color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.color_.IsDefault()) {
    _impl_.color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ether.draw.Arrow.color)
}

// float width = 6;
inline void Arrow::clear_width() {
  _impl_.width_ = 0;
}
inline float Arrow::_internal_width() const {
  return _impl_.width_;
}
inline float Arrow::width() const {
  // @@protoc_insertion_point(field_get:ether.draw.Arrow.width)
  return _internal_width();
}
inline void Arrow::_internal_set_width(float value) {
  
  _impl_.width_ = value;
}
inline void Arrow::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:ether.draw.Arrow.width)
}

// -------------------------------------------------------------------

// Polygon

// repeated float x_list = 1;
inline int Polygon::_internal_x_list_size() const {
  return _impl_.x_list_.size();
}
inline int Polygon::x_list_size() const {
  return _internal_x_list_size();
}
inline void Polygon::clear_x_list() {
  _impl_.x_list_.Clear();
}
inline float Polygon::_internal_x_list(int index) const {
  return _impl_.x_list_.Get(index);
}
inline float Polygon::x_list(int index) const {
  // @@protoc_insertion_point(field_get:ether.draw.Polygon.x_list)
  return _internal_x_list(index);
}
inline void Polygon::set_x_list(int index, float value) {
  _impl_.x_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:ether.draw.Polygon.x_list)
}
inline void Polygon::_internal_add_x_list(float value) {
  _impl_.x_list_.Add(value);
}
inline void Polygon::add_x_list(float value) {
  _internal_add_x_list(value);
  // @@protoc_insertion_point(field_add:ether.draw.Polygon.x_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Polygon::_internal_x_list() const {
  return _impl_.x_list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Polygon::x_list() const {
  // @@protoc_insertion_point(field_list:ether.draw.Polygon.x_list)
  return _internal_x_list();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Polygon::_internal_mutable_x_list() {
  return &_impl_.x_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Polygon::mutable_x_list() {
  // @@protoc_insertion_point(field_mutable_list:ether.draw.Polygon.x_list)
  return _internal_mutable_x_list();
}

// repeated float y_list = 2;
inline int Polygon::_internal_y_list_size() const {
  return _impl_.y_list_.size();
}
inline int Polygon::y_list_size() const {
  return _internal_y_list_size();
}
inline void Polygon::clear_y_list() {
  _impl_.y_list_.Clear();
}
inline float Polygon::_internal_y_list(int index) const {
  return _impl_.y_list_.Get(index);
}
inline float Polygon::y_list(int index) const {
  // @@protoc_insertion_point(field_get:ether.draw.Polygon.y_list)
  return _internal_y_list(index);
}
inline void Polygon::set_y_list(int index, float value) {
  _impl_.y_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:ether.draw.Polygon.y_list)
}
inline void Polygon::_internal_add_y_list(float value) {
  _impl_.y_list_.Add(value);
}
inline void Polygon::add_y_list(float value) {
  _internal_add_y_list(value);
  // @@protoc_insertion_point(field_add:ether.draw.Polygon.y_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Polygon::_internal_y_list() const {
  return _impl_.y_list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
Polygon::y_list() const {
  // @@protoc_insertion_point(field_list:ether.draw.Polygon.y_list)
  return _internal_y_list();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Polygon::_internal_mutable_y_list() {
  return &_impl_.y_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
Polygon::mutable_y_list() {
  // @@protoc_insertion_point(field_mutable_list:ether.draw.Polygon.y_list)
  return _internal_mutable_y_list();
}

// string color = 3;
inline void Polygon::clear_color() {
  _impl_.color_.ClearToEmpty();
}
inline const std::string& Polygon::color() const {
  // @@protoc_insertion_point(field_get:ether.draw.Polygon.color)
  return _internal_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Polygon::set_color(ArgT0&& arg0, ArgT... args) {
 
 _impl_.color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ether.draw.Polygon.color)
}
inline std::string* Polygon::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:ether.draw.Polygon.color)
  return _s;
}
inline const std::string& Polygon::_internal_color() const {
  return _impl_.color_.Get();
}
inline void Polygon::_internal_set_color(const std::string& value) {
  
  _impl_.color_.Set(value, GetArenaForAllocation());
}
inline std::string* Polygon::_internal_mutable_color() {
  
  return _impl_.color_.Mutable(GetArenaForAllocation());
}
inline std::string* Polygon::release_color() {
  // @@protoc_insertion_point(field_release:ether.draw.Polygon.color)
  return _impl_.color_.Release();
}
inline void Polygon::set_allocated_color(std::string* color) {
  if (color != nullptr) {
    
  } else {
    
  }
  _impl_.color_.SetAllocated(color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.color_.IsDefault()) {
    _impl_.color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ether.draw.Polygon.color)
}

// float width = 4;
inline void Polygon::clear_width() {
  _impl_.width_ = 0;
}
inline float Polygon::_internal_width() const {
  return _impl_.width_;
}
inline float Polygon::width() const {
  // @@protoc_insertion_point(field_get:ether.draw.Polygon.width)
  return _internal_width();
}
inline void Polygon::_internal_set_width(float value) {
  
  _impl_.width_ = value;
}
inline void Polygon::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:ether.draw.Polygon.width)
}

// -------------------------------------------------------------------

// Rect

// float x = 1;
inline void Rect::clear_x() {
  _impl_.x_ = 0;
}
inline float Rect::_internal_x() const {
  return _impl_.x_;
}
inline float Rect::x() const {
  // @@protoc_insertion_point(field_get:ether.draw.Rect.x)
  return _internal_x();
}
inline void Rect::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Rect::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:ether.draw.Rect.x)
}

// float y = 2;
inline void Rect::clear_y() {
  _impl_.y_ = 0;
}
inline float Rect::_internal_y() const {
  return _impl_.y_;
}
inline float Rect::y() const {
  // @@protoc_insertion_point(field_get:ether.draw.Rect.y)
  return _internal_y();
}
inline void Rect::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Rect::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:ether.draw.Rect.y)
}

// float width = 3;
inline void Rect::clear_width() {
  _impl_.width_ = 0;
}
inline float Rect::_internal_width() const {
  return _impl_.width_;
}
inline float Rect::width() const {
  // @@protoc_insertion_point(field_get:ether.draw.Rect.width)
  return _internal_width();
}
inline void Rect::_internal_set_width(float value) {
  
  _impl_.width_ = value;
}
inline void Rect::set_width(float value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:ether.draw.Rect.width)
}

// float height = 4;
inline void Rect::clear_height() {
  _impl_.height_ = 0;
}
inline float Rect::_internal_height() const {
  return _impl_.height_;
}
inline float Rect::height() const {
  // @@protoc_insertion_point(field_get:ether.draw.Rect.height)
  return _internal_height();
}
inline void Rect::_internal_set_height(float value) {
  
  _impl_.height_ = value;
}
inline void Rect::set_height(float value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:ether.draw.Rect.height)
}

// string color = 5;
inline void Rect::clear_color() {
  _impl_.color_.ClearToEmpty();
}
inline const std::string& Rect::color() const {
  // @@protoc_insertion_point(field_get:ether.draw.Rect.color)
  return _internal_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Rect::set_color(ArgT0&& arg0, ArgT... args) {
 
 _impl_.color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ether.draw.Rect.color)
}
inline std::string* Rect::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:ether.draw.Rect.color)
  return _s;
}
inline const std::string& Rect::_internal_color() const {
  return _impl_.color_.Get();
}
inline void Rect::_internal_set_color(const std::string& value) {
  
  _impl_.color_.Set(value, GetArenaForAllocation());
}
inline std::string* Rect::_internal_mutable_color() {
  
  return _impl_.color_.Mutable(GetArenaForAllocation());
}
inline std::string* Rect::release_color() {
  // @@protoc_insertion_point(field_release:ether.draw.Rect.color)
  return _impl_.color_.Release();
}
inline void Rect::set_allocated_color(std::string* color) {
  if (color != nullptr) {
    
  } else {
    
  }
  _impl_.color_.SetAllocated(color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.color_.IsDefault()) {
    _impl_.color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ether.draw.Rect.color)
}

// -------------------------------------------------------------------

// Circle

// float x = 1;
inline void Circle::clear_x() {
  _impl_.x_ = 0;
}
inline float Circle::_internal_x() const {
  return _impl_.x_;
}
inline float Circle::x() const {
  // @@protoc_insertion_point(field_get:ether.draw.Circle.x)
  return _internal_x();
}
inline void Circle::_internal_set_x(float value) {
  
  _impl_.x_ = value;
}
inline void Circle::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:ether.draw.Circle.x)
}

// float y = 2;
inline void Circle::clear_y() {
  _impl_.y_ = 0;
}
inline float Circle::_internal_y() const {
  return _impl_.y_;
}
inline float Circle::y() const {
  // @@protoc_insertion_point(field_get:ether.draw.Circle.y)
  return _internal_y();
}
inline void Circle::_internal_set_y(float value) {
  
  _impl_.y_ = value;
}
inline void Circle::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:ether.draw.Circle.y)
}

// float radius = 3;
inline void Circle::clear_radius() {
  _impl_.radius_ = 0;
}
inline float Circle::_internal_radius() const {
  return _impl_.radius_;
}
inline float Circle::radius() const {
  // @@protoc_insertion_point(field_get:ether.draw.Circle.radius)
  return _internal_radius();
}
inline void Circle::_internal_set_radius(float value) {
  
  _impl_.radius_ = value;
}
inline void Circle::set_radius(float value) {
  _internal_set_radius(value);
  // @@protoc_insertion_point(field_set:ether.draw.Circle.radius)
}

// string color = 4;
inline void Circle::clear_color() {
  _impl_.color_.ClearToEmpty();
}
inline const std::string& Circle::color() const {
  // @@protoc_insertion_point(field_get:ether.draw.Circle.color)
  return _internal_color();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Circle::set_color(ArgT0&& arg0, ArgT... args) {
 
 _impl_.color_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ether.draw.Circle.color)
}
inline std::string* Circle::mutable_color() {
  std::string* _s = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:ether.draw.Circle.color)
  return _s;
}
inline const std::string& Circle::_internal_color() const {
  return _impl_.color_.Get();
}
inline void Circle::_internal_set_color(const std::string& value) {
  
  _impl_.color_.Set(value, GetArenaForAllocation());
}
inline std::string* Circle::_internal_mutable_color() {
  
  return _impl_.color_.Mutable(GetArenaForAllocation());
}
inline std::string* Circle::release_color() {
  // @@protoc_insertion_point(field_release:ether.draw.Circle.color)
  return _impl_.color_.Release();
}
inline void Circle::set_allocated_color(std::string* color) {
  if (color != nullptr) {
    
  } else {
    
  }
  _impl_.color_.SetAllocated(color, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.color_.IsDefault()) {
    _impl_.color_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ether.draw.Circle.color)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace draw
}  // namespace ether

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ether_2fdraw_2eproto
