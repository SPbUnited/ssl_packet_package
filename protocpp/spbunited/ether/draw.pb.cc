// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ether/draw.proto

#include "ether/draw.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace ether {
namespace draw {
PROTOBUF_CONSTEXPR DrawCommand_LayersEntry_DoNotUse::DrawCommand_LayersEntry_DoNotUse(
    ::_pbi::ConstantInitialized) {}
struct DrawCommand_LayersEntry_DoNotUseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DrawCommand_LayersEntry_DoNotUseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DrawCommand_LayersEntry_DoNotUseDefaultTypeInternal() {}
  union {
    DrawCommand_LayersEntry_DoNotUse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DrawCommand_LayersEntry_DoNotUseDefaultTypeInternal _DrawCommand_LayersEntry_DoNotUse_default_instance_;
PROTOBUF_CONSTEXPR DrawCommand::DrawCommand(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.layers_)*/{::_pbi::ConstantInitialized()}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct DrawCommandDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DrawCommandDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DrawCommandDefaultTypeInternal() {}
  union {
    DrawCommand _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DrawCommandDefaultTypeInternal _DrawCommand_default_instance_;
PROTOBUF_CONSTEXPR Layer::Layer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.data_)*/{}
  , /*decltype(_impl_.is_visible_)*/false
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LayerDefaultTypeInternal() {}
  union {
    Layer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LayerDefaultTypeInternal _Layer_default_instance_;
PROTOBUF_CONSTEXPR DrawObject::DrawObject(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.object_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct DrawObjectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DrawObjectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DrawObjectDefaultTypeInternal() {}
  union {
    DrawObject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DrawObjectDefaultTypeInternal _DrawObject_default_instance_;
PROTOBUF_CONSTEXPR RobotYel::RobotYel(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.rotation_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RobotYelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RobotYelDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RobotYelDefaultTypeInternal() {}
  union {
    RobotYel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RobotYelDefaultTypeInternal _RobotYel_default_instance_;
PROTOBUF_CONSTEXPR RobotBlu::RobotBlu(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.rotation_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RobotBluDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RobotBluDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RobotBluDefaultTypeInternal() {}
  union {
    RobotBlu _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RobotBluDefaultTypeInternal _RobotBlu_default_instance_;
PROTOBUF_CONSTEXPR Ball::Ball(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct BallDefaultTypeInternal {
  PROTOBUF_CONSTEXPR BallDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~BallDefaultTypeInternal() {}
  union {
    Ball _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 BallDefaultTypeInternal _Ball_default_instance_;
PROTOBUF_CONSTEXPR Line::Line(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_list_)*/{}
  , /*decltype(_impl_.y_list_)*/{}
  , /*decltype(_impl_.color_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct LineDefaultTypeInternal {
  PROTOBUF_CONSTEXPR LineDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~LineDefaultTypeInternal() {}
  union {
    Line _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 LineDefaultTypeInternal _Line_default_instance_;
PROTOBUF_CONSTEXPR Arrow::Arrow(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.color_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.dx_)*/0
  , /*decltype(_impl_.dy_)*/0
  , /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct ArrowDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ArrowDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ArrowDefaultTypeInternal() {}
  union {
    Arrow _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ArrowDefaultTypeInternal _Arrow_default_instance_;
PROTOBUF_CONSTEXPR Polygon::Polygon(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.x_list_)*/{}
  , /*decltype(_impl_.y_list_)*/{}
  , /*decltype(_impl_.color_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct PolygonDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PolygonDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~PolygonDefaultTypeInternal() {}
  union {
    Polygon _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PolygonDefaultTypeInternal _Polygon_default_instance_;
PROTOBUF_CONSTEXPR Rect::Rect(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.color_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_.height_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct RectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR RectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~RectDefaultTypeInternal() {}
  union {
    Rect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 RectDefaultTypeInternal _Rect_default_instance_;
PROTOBUF_CONSTEXPR Circle::Circle(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.color_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.x_)*/0
  , /*decltype(_impl_.y_)*/0
  , /*decltype(_impl_.radius_)*/0
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CircleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CircleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CircleDefaultTypeInternal() {}
  union {
    Circle _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CircleDefaultTypeInternal _Circle_default_instance_;
}  // namespace draw
}  // namespace ether
static ::_pb::Metadata file_level_metadata_ether_2fdraw_2eproto[12];
static constexpr ::_pb::EnumDescriptor const** file_level_enum_descriptors_ether_2fdraw_2eproto = nullptr;
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_ether_2fdraw_2eproto = nullptr;

const uint32_t TableStruct_ether_2fdraw_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::ether::draw::DrawCommand_LayersEntry_DoNotUse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::DrawCommand_LayersEntry_DoNotUse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ether::draw::DrawCommand_LayersEntry_DoNotUse, key_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::DrawCommand_LayersEntry_DoNotUse, value_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ether::draw::DrawCommand, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ether::draw::DrawCommand, _impl_.layers_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ether::draw::Layer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ether::draw::Layer, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::Layer, _impl_.is_visible_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ether::draw::DrawObject, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::ether::draw::DrawObject, _impl_._oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  ::_pbi::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::ether::draw::DrawObject, _impl_.object_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ether::draw::RobotYel, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ether::draw::RobotYel, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::RobotYel, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::RobotYel, _impl_.rotation_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ether::draw::RobotBlu, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ether::draw::RobotBlu, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::RobotBlu, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::RobotBlu, _impl_.rotation_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ether::draw::Ball, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ether::draw::Ball, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::Ball, _impl_.y_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ether::draw::Line, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ether::draw::Line, _impl_.x_list_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::Line, _impl_.y_list_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::Line, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::Line, _impl_.width_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ether::draw::Arrow, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ether::draw::Arrow, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::Arrow, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::Arrow, _impl_.dx_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::Arrow, _impl_.dy_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::Arrow, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::Arrow, _impl_.width_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ether::draw::Polygon, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ether::draw::Polygon, _impl_.x_list_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::Polygon, _impl_.y_list_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::Polygon, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::Polygon, _impl_.width_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ether::draw::Rect, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ether::draw::Rect, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::Rect, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::Rect, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::Rect, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::Rect, _impl_.color_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::ether::draw::Circle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ether::draw::Circle, _impl_.x_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::Circle, _impl_.y_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::Circle, _impl_.radius_),
  PROTOBUF_FIELD_OFFSET(::ether::draw::Circle, _impl_.color_),
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::ether::draw::DrawCommand_LayersEntry_DoNotUse)},
  { 10, -1, -1, sizeof(::ether::draw::DrawCommand)},
  { 17, -1, -1, sizeof(::ether::draw::Layer)},
  { 25, -1, -1, sizeof(::ether::draw::DrawObject)},
  { 40, -1, -1, sizeof(::ether::draw::RobotYel)},
  { 49, -1, -1, sizeof(::ether::draw::RobotBlu)},
  { 58, -1, -1, sizeof(::ether::draw::Ball)},
  { 66, -1, -1, sizeof(::ether::draw::Line)},
  { 76, -1, -1, sizeof(::ether::draw::Arrow)},
  { 88, -1, -1, sizeof(::ether::draw::Polygon)},
  { 98, -1, -1, sizeof(::ether::draw::Rect)},
  { 109, -1, -1, sizeof(::ether::draw::Circle)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::ether::draw::_DrawCommand_LayersEntry_DoNotUse_default_instance_._instance,
  &::ether::draw::_DrawCommand_default_instance_._instance,
  &::ether::draw::_Layer_default_instance_._instance,
  &::ether::draw::_DrawObject_default_instance_._instance,
  &::ether::draw::_RobotYel_default_instance_._instance,
  &::ether::draw::_RobotBlu_default_instance_._instance,
  &::ether::draw::_Ball_default_instance_._instance,
  &::ether::draw::_Line_default_instance_._instance,
  &::ether::draw::_Arrow_default_instance_._instance,
  &::ether::draw::_Polygon_default_instance_._instance,
  &::ether::draw::_Rect_default_instance_._instance,
  &::ether::draw::_Circle_default_instance_._instance,
};

const char descriptor_table_protodef_ether_2fdraw_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\020ether/draw.proto\022\nether.draw\"\204\001\n\013DrawC"
  "ommand\0223\n\006layers\030\001 \003(\0132#.ether.draw.Draw"
  "Command.LayersEntry\032@\n\013LayersEntry\022\013\n\003ke"
  "y\030\001 \001(\t\022 \n\005value\030\002 \001(\0132\021.ether.draw.Laye"
  "r:\0028\001\"A\n\005Layer\022$\n\004data\030\001 \003(\0132\026.ether.dra"
  "w.DrawObject\022\022\n\nis_visible\030\002 \001(\010\"\304\002\n\nDra"
  "wObject\022)\n\trobot_yel\030\001 \001(\0132\024.ether.draw."
  "RobotYelH\000\022)\n\trobot_blu\030\002 \001(\0132\024.ether.dr"
  "aw.RobotBluH\000\022 \n\004ball\030\003 \001(\0132\020.ether.draw"
  ".BallH\000\022 \n\004line\030\004 \001(\0132\020.ether.draw.LineH"
  "\000\022\"\n\005arrow\030\005 \001(\0132\021.ether.draw.ArrowH\000\022&\n"
  "\007polygon\030\006 \001(\0132\023.ether.draw.PolygonH\000\022 \n"
  "\004rect\030\007 \001(\0132\020.ether.draw.RectH\000\022$\n\006circl"
  "e\030\010 \001(\0132\022.ether.draw.CircleH\000B\010\n\006object\""
  "2\n\010RobotYel\022\t\n\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\020\n\010rot"
  "ation\030\003 \001(\002\"2\n\010RobotBlu\022\t\n\001x\030\001 \001(\002\022\t\n\001y\030"
  "\002 \001(\002\022\020\n\010rotation\030\003 \001(\002\"\034\n\004Ball\022\t\n\001x\030\001 \001"
  "(\002\022\t\n\001y\030\002 \001(\002\"D\n\004Line\022\016\n\006x_list\030\001 \003(\002\022\016\n"
  "\006y_list\030\002 \003(\002\022\r\n\005color\030\003 \001(\t\022\r\n\005width\030\004 "
  "\001(\002\"S\n\005Arrow\022\t\n\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\n\n\002dx"
  "\030\003 \001(\002\022\n\n\002dy\030\004 \001(\002\022\r\n\005color\030\005 \001(\t\022\r\n\005wid"
  "th\030\006 \001(\002\"G\n\007Polygon\022\016\n\006x_list\030\001 \003(\002\022\016\n\006y"
  "_list\030\002 \003(\002\022\r\n\005color\030\003 \001(\t\022\r\n\005width\030\004 \001("
  "\002\"J\n\004Rect\022\t\n\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\r\n\005width"
  "\030\003 \001(\002\022\016\n\006height\030\004 \001(\002\022\r\n\005color\030\005 \001(\t\"=\n"
  "\006Circle\022\t\n\001x\030\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\016\n\006radius\030"
  "\003 \001(\002\022\r\n\005color\030\004 \001(\tb\006proto3"
  ;
static ::_pbi::once_flag descriptor_table_ether_2fdraw_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_ether_2fdraw_2eproto = {
    false, false, 1068, descriptor_table_protodef_ether_2fdraw_2eproto,
    "ether/draw.proto",
    &descriptor_table_ether_2fdraw_2eproto_once, nullptr, 0, 12,
    schemas, file_default_instances, TableStruct_ether_2fdraw_2eproto::offsets,
    file_level_metadata_ether_2fdraw_2eproto, file_level_enum_descriptors_ether_2fdraw_2eproto,
    file_level_service_descriptors_ether_2fdraw_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_ether_2fdraw_2eproto_getter() {
  return &descriptor_table_ether_2fdraw_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_ether_2fdraw_2eproto(&descriptor_table_ether_2fdraw_2eproto);
namespace ether {
namespace draw {

// ===================================================================

DrawCommand_LayersEntry_DoNotUse::DrawCommand_LayersEntry_DoNotUse() {}
DrawCommand_LayersEntry_DoNotUse::DrawCommand_LayersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena)
    : SuperType(arena) {}
void DrawCommand_LayersEntry_DoNotUse::MergeFrom(const DrawCommand_LayersEntry_DoNotUse& other) {
  MergeFromInternal(other);
}
::PROTOBUF_NAMESPACE_ID::Metadata DrawCommand_LayersEntry_DoNotUse::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ether_2fdraw_2eproto_getter, &descriptor_table_ether_2fdraw_2eproto_once,
      file_level_metadata_ether_2fdraw_2eproto[0]);
}

// ===================================================================

class DrawCommand::_Internal {
 public:
};

DrawCommand::DrawCommand(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  if (arena != nullptr && !is_message_owned) {
    arena->OwnCustomDestructor(this, &DrawCommand::ArenaDtor);
  }
  // @@protoc_insertion_point(arena_constructor:ether.draw.DrawCommand)
}
DrawCommand::DrawCommand(const DrawCommand& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DrawCommand* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      /*decltype(_impl_.layers_)*/{}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.layers_.MergeFrom(from._impl_.layers_);
  // @@protoc_insertion_point(copy_constructor:ether.draw.DrawCommand)
}

inline void DrawCommand::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      /*decltype(_impl_.layers_)*/{::_pbi::ArenaInitialized(), arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

DrawCommand::~DrawCommand() {
  // @@protoc_insertion_point(destructor:ether.draw.DrawCommand)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    ArenaDtor(this);
    return;
  }
  SharedDtor();
}

inline void DrawCommand::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.layers_.Destruct();
  _impl_.layers_.~MapField();
}

void DrawCommand::ArenaDtor(void* object) {
  DrawCommand* _this = reinterpret_cast< DrawCommand* >(object);
  _this->_impl_.layers_.Destruct();
}
void DrawCommand::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DrawCommand::Clear() {
// @@protoc_insertion_point(message_clear_start:ether.draw.DrawCommand)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.layers_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DrawCommand::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // map<string, .ether.draw.Layer> layers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(&_impl_.layers_, ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DrawCommand::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ether.draw.DrawCommand)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // map<string, .ether.draw.Layer> layers = 1;
  if (!this->_internal_layers().empty()) {
    using MapType = ::_pb::Map<std::string, ::ether::draw::Layer>;
    using WireHelper = DrawCommand_LayersEntry_DoNotUse::Funcs;
    const auto& map_field = this->_internal_layers();
    auto check_utf8 = [](const MapType::value_type& entry) {
      (void)entry;
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
        entry.first.data(), static_cast<int>(entry.first.length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
        "ether.draw.DrawCommand.LayersEntry.key");
    };

    if (stream->IsSerializationDeterministic() && map_field.size() > 1) {
      for (const auto& entry : ::_pbi::MapSorterPtr<MapType>(map_field)) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    } else {
      for (const auto& entry : map_field) {
        target = WireHelper::InternalSerialize(1, entry.first, entry.second, target, stream);
        check_utf8(entry);
      }
    }
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ether.draw.DrawCommand)
  return target;
}

size_t DrawCommand::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ether.draw.DrawCommand)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // map<string, .ether.draw.Layer> layers = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_layers_size());
  for (::PROTOBUF_NAMESPACE_ID::Map< std::string, ::ether::draw::Layer >::const_iterator
      it = this->_internal_layers().begin();
      it != this->_internal_layers().end(); ++it) {
    total_size += DrawCommand_LayersEntry_DoNotUse::Funcs::ByteSizeLong(it->first, it->second);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DrawCommand::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DrawCommand::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DrawCommand::GetClassData() const { return &_class_data_; }


void DrawCommand::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DrawCommand*>(&to_msg);
  auto& from = static_cast<const DrawCommand&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ether.draw.DrawCommand)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.layers_.MergeFrom(from._impl_.layers_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DrawCommand::CopyFrom(const DrawCommand& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ether.draw.DrawCommand)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DrawCommand::IsInitialized() const {
  return true;
}

void DrawCommand::InternalSwap(DrawCommand* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.layers_.InternalSwap(&other->_impl_.layers_);
}

::PROTOBUF_NAMESPACE_ID::Metadata DrawCommand::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ether_2fdraw_2eproto_getter, &descriptor_table_ether_2fdraw_2eproto_once,
      file_level_metadata_ether_2fdraw_2eproto[1]);
}

// ===================================================================

class Layer::_Internal {
 public:
};

Layer::Layer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ether.draw.Layer)
}
Layer::Layer(const Layer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Layer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){from._impl_.data_}
    , decltype(_impl_.is_visible_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.is_visible_ = from._impl_.is_visible_;
  // @@protoc_insertion_point(copy_constructor:ether.draw.Layer)
}

inline void Layer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.data_){arena}
    , decltype(_impl_.is_visible_){false}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Layer::~Layer() {
  // @@protoc_insertion_point(destructor:ether.draw.Layer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Layer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.~RepeatedPtrField();
}

void Layer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Layer::Clear() {
// @@protoc_insertion_point(message_clear_start:ether.draw.Layer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.data_.Clear();
  _impl_.is_visible_ = false;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Layer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ether.draw.DrawObject data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_data(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool is_visible = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _impl_.is_visible_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Layer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ether.draw.Layer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ether.draw.DrawObject data = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_data_size()); i < n; i++) {
    const auto& repfield = this->_internal_data(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // bool is_visible = 2;
  if (this->_internal_is_visible() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(2, this->_internal_is_visible(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ether.draw.Layer)
  return target;
}

size_t Layer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ether.draw.Layer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ether.draw.DrawObject data = 1;
  total_size += 1UL * this->_internal_data_size();
  for (const auto& msg : this->_impl_.data_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // bool is_visible = 2;
  if (this->_internal_is_visible() != 0) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Layer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Layer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Layer::GetClassData() const { return &_class_data_; }


void Layer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Layer*>(&to_msg);
  auto& from = static_cast<const Layer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ether.draw.Layer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.data_.MergeFrom(from._impl_.data_);
  if (from._internal_is_visible() != 0) {
    _this->_internal_set_is_visible(from._internal_is_visible());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Layer::CopyFrom(const Layer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ether.draw.Layer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Layer::IsInitialized() const {
  return true;
}

void Layer::InternalSwap(Layer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.data_.InternalSwap(&other->_impl_.data_);
  swap(_impl_.is_visible_, other->_impl_.is_visible_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Layer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ether_2fdraw_2eproto_getter, &descriptor_table_ether_2fdraw_2eproto_once,
      file_level_metadata_ether_2fdraw_2eproto[2]);
}

// ===================================================================

class DrawObject::_Internal {
 public:
  static const ::ether::draw::RobotYel& robot_yel(const DrawObject* msg);
  static const ::ether::draw::RobotBlu& robot_blu(const DrawObject* msg);
  static const ::ether::draw::Ball& ball(const DrawObject* msg);
  static const ::ether::draw::Line& line(const DrawObject* msg);
  static const ::ether::draw::Arrow& arrow(const DrawObject* msg);
  static const ::ether::draw::Polygon& polygon(const DrawObject* msg);
  static const ::ether::draw::Rect& rect(const DrawObject* msg);
  static const ::ether::draw::Circle& circle(const DrawObject* msg);
};

const ::ether::draw::RobotYel&
DrawObject::_Internal::robot_yel(const DrawObject* msg) {
  return *msg->_impl_.object_.robot_yel_;
}
const ::ether::draw::RobotBlu&
DrawObject::_Internal::robot_blu(const DrawObject* msg) {
  return *msg->_impl_.object_.robot_blu_;
}
const ::ether::draw::Ball&
DrawObject::_Internal::ball(const DrawObject* msg) {
  return *msg->_impl_.object_.ball_;
}
const ::ether::draw::Line&
DrawObject::_Internal::line(const DrawObject* msg) {
  return *msg->_impl_.object_.line_;
}
const ::ether::draw::Arrow&
DrawObject::_Internal::arrow(const DrawObject* msg) {
  return *msg->_impl_.object_.arrow_;
}
const ::ether::draw::Polygon&
DrawObject::_Internal::polygon(const DrawObject* msg) {
  return *msg->_impl_.object_.polygon_;
}
const ::ether::draw::Rect&
DrawObject::_Internal::rect(const DrawObject* msg) {
  return *msg->_impl_.object_.rect_;
}
const ::ether::draw::Circle&
DrawObject::_Internal::circle(const DrawObject* msg) {
  return *msg->_impl_.object_.circle_;
}
void DrawObject::set_allocated_robot_yel(::ether::draw::RobotYel* robot_yel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_object();
  if (robot_yel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(robot_yel);
    if (message_arena != submessage_arena) {
      robot_yel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot_yel, submessage_arena);
    }
    set_has_robot_yel();
    _impl_.object_.robot_yel_ = robot_yel;
  }
  // @@protoc_insertion_point(field_set_allocated:ether.draw.DrawObject.robot_yel)
}
void DrawObject::set_allocated_robot_blu(::ether::draw::RobotBlu* robot_blu) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_object();
  if (robot_blu) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(robot_blu);
    if (message_arena != submessage_arena) {
      robot_blu = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, robot_blu, submessage_arena);
    }
    set_has_robot_blu();
    _impl_.object_.robot_blu_ = robot_blu;
  }
  // @@protoc_insertion_point(field_set_allocated:ether.draw.DrawObject.robot_blu)
}
void DrawObject::set_allocated_ball(::ether::draw::Ball* ball) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_object();
  if (ball) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ball);
    if (message_arena != submessage_arena) {
      ball = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ball, submessage_arena);
    }
    set_has_ball();
    _impl_.object_.ball_ = ball;
  }
  // @@protoc_insertion_point(field_set_allocated:ether.draw.DrawObject.ball)
}
void DrawObject::set_allocated_line(::ether::draw::Line* line) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_object();
  if (line) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(line);
    if (message_arena != submessage_arena) {
      line = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, line, submessage_arena);
    }
    set_has_line();
    _impl_.object_.line_ = line;
  }
  // @@protoc_insertion_point(field_set_allocated:ether.draw.DrawObject.line)
}
void DrawObject::set_allocated_arrow(::ether::draw::Arrow* arrow) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_object();
  if (arrow) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(arrow);
    if (message_arena != submessage_arena) {
      arrow = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, arrow, submessage_arena);
    }
    set_has_arrow();
    _impl_.object_.arrow_ = arrow;
  }
  // @@protoc_insertion_point(field_set_allocated:ether.draw.DrawObject.arrow)
}
void DrawObject::set_allocated_polygon(::ether::draw::Polygon* polygon) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_object();
  if (polygon) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(polygon);
    if (message_arena != submessage_arena) {
      polygon = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, polygon, submessage_arena);
    }
    set_has_polygon();
    _impl_.object_.polygon_ = polygon;
  }
  // @@protoc_insertion_point(field_set_allocated:ether.draw.DrawObject.polygon)
}
void DrawObject::set_allocated_rect(::ether::draw::Rect* rect) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_object();
  if (rect) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rect);
    if (message_arena != submessage_arena) {
      rect = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rect, submessage_arena);
    }
    set_has_rect();
    _impl_.object_.rect_ = rect;
  }
  // @@protoc_insertion_point(field_set_allocated:ether.draw.DrawObject.rect)
}
void DrawObject::set_allocated_circle(::ether::draw::Circle* circle) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_object();
  if (circle) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(circle);
    if (message_arena != submessage_arena) {
      circle = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circle, submessage_arena);
    }
    set_has_circle();
    _impl_.object_.circle_ = circle;
  }
  // @@protoc_insertion_point(field_set_allocated:ether.draw.DrawObject.circle)
}
DrawObject::DrawObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ether.draw.DrawObject)
}
DrawObject::DrawObject(const DrawObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  DrawObject* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.object_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_object();
  switch (from.object_case()) {
    case kRobotYel: {
      _this->_internal_mutable_robot_yel()->::ether::draw::RobotYel::MergeFrom(
          from._internal_robot_yel());
      break;
    }
    case kRobotBlu: {
      _this->_internal_mutable_robot_blu()->::ether::draw::RobotBlu::MergeFrom(
          from._internal_robot_blu());
      break;
    }
    case kBall: {
      _this->_internal_mutable_ball()->::ether::draw::Ball::MergeFrom(
          from._internal_ball());
      break;
    }
    case kLine: {
      _this->_internal_mutable_line()->::ether::draw::Line::MergeFrom(
          from._internal_line());
      break;
    }
    case kArrow: {
      _this->_internal_mutable_arrow()->::ether::draw::Arrow::MergeFrom(
          from._internal_arrow());
      break;
    }
    case kPolygon: {
      _this->_internal_mutable_polygon()->::ether::draw::Polygon::MergeFrom(
          from._internal_polygon());
      break;
    }
    case kRect: {
      _this->_internal_mutable_rect()->::ether::draw::Rect::MergeFrom(
          from._internal_rect());
      break;
    }
    case kCircle: {
      _this->_internal_mutable_circle()->::ether::draw::Circle::MergeFrom(
          from._internal_circle());
      break;
    }
    case OBJECT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:ether.draw.DrawObject)
}

inline void DrawObject::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.object_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_object();
}

DrawObject::~DrawObject() {
  // @@protoc_insertion_point(destructor:ether.draw.DrawObject)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DrawObject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_object()) {
    clear_object();
  }
}

void DrawObject::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void DrawObject::clear_object() {
// @@protoc_insertion_point(one_of_clear_start:ether.draw.DrawObject)
  switch (object_case()) {
    case kRobotYel: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.object_.robot_yel_;
      }
      break;
    }
    case kRobotBlu: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.object_.robot_blu_;
      }
      break;
    }
    case kBall: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.object_.ball_;
      }
      break;
    }
    case kLine: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.object_.line_;
      }
      break;
    }
    case kArrow: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.object_.arrow_;
      }
      break;
    }
    case kPolygon: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.object_.polygon_;
      }
      break;
    }
    case kRect: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.object_.rect_;
      }
      break;
    }
    case kCircle: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.object_.circle_;
      }
      break;
    }
    case OBJECT_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = OBJECT_NOT_SET;
}


void DrawObject::Clear() {
// @@protoc_insertion_point(message_clear_start:ether.draw.DrawObject)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_object();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* DrawObject::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .ether.draw.RobotYel robot_yel = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_robot_yel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ether.draw.RobotBlu robot_blu = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_robot_blu(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ether.draw.Ball ball = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_ball(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ether.draw.Line line = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_line(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ether.draw.Arrow arrow = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_arrow(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ether.draw.Polygon polygon = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_polygon(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ether.draw.Rect rect = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_rect(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .ether.draw.Circle circle = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_circle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DrawObject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ether.draw.DrawObject)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .ether.draw.RobotYel robot_yel = 1;
  if (_internal_has_robot_yel()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::robot_yel(this),
        _Internal::robot_yel(this).GetCachedSize(), target, stream);
  }

  // .ether.draw.RobotBlu robot_blu = 2;
  if (_internal_has_robot_blu()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::robot_blu(this),
        _Internal::robot_blu(this).GetCachedSize(), target, stream);
  }

  // .ether.draw.Ball ball = 3;
  if (_internal_has_ball()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::ball(this),
        _Internal::ball(this).GetCachedSize(), target, stream);
  }

  // .ether.draw.Line line = 4;
  if (_internal_has_line()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::line(this),
        _Internal::line(this).GetCachedSize(), target, stream);
  }

  // .ether.draw.Arrow arrow = 5;
  if (_internal_has_arrow()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::arrow(this),
        _Internal::arrow(this).GetCachedSize(), target, stream);
  }

  // .ether.draw.Polygon polygon = 6;
  if (_internal_has_polygon()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::polygon(this),
        _Internal::polygon(this).GetCachedSize(), target, stream);
  }

  // .ether.draw.Rect rect = 7;
  if (_internal_has_rect()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::rect(this),
        _Internal::rect(this).GetCachedSize(), target, stream);
  }

  // .ether.draw.Circle circle = 8;
  if (_internal_has_circle()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::circle(this),
        _Internal::circle(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ether.draw.DrawObject)
  return target;
}

size_t DrawObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ether.draw.DrawObject)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (object_case()) {
    // .ether.draw.RobotYel robot_yel = 1;
    case kRobotYel: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.object_.robot_yel_);
      break;
    }
    // .ether.draw.RobotBlu robot_blu = 2;
    case kRobotBlu: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.object_.robot_blu_);
      break;
    }
    // .ether.draw.Ball ball = 3;
    case kBall: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.object_.ball_);
      break;
    }
    // .ether.draw.Line line = 4;
    case kLine: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.object_.line_);
      break;
    }
    // .ether.draw.Arrow arrow = 5;
    case kArrow: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.object_.arrow_);
      break;
    }
    // .ether.draw.Polygon polygon = 6;
    case kPolygon: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.object_.polygon_);
      break;
    }
    // .ether.draw.Rect rect = 7;
    case kRect: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.object_.rect_);
      break;
    }
    // .ether.draw.Circle circle = 8;
    case kCircle: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.object_.circle_);
      break;
    }
    case OBJECT_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData DrawObject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    DrawObject::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*DrawObject::GetClassData() const { return &_class_data_; }


void DrawObject::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<DrawObject*>(&to_msg);
  auto& from = static_cast<const DrawObject&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ether.draw.DrawObject)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.object_case()) {
    case kRobotYel: {
      _this->_internal_mutable_robot_yel()->::ether::draw::RobotYel::MergeFrom(
          from._internal_robot_yel());
      break;
    }
    case kRobotBlu: {
      _this->_internal_mutable_robot_blu()->::ether::draw::RobotBlu::MergeFrom(
          from._internal_robot_blu());
      break;
    }
    case kBall: {
      _this->_internal_mutable_ball()->::ether::draw::Ball::MergeFrom(
          from._internal_ball());
      break;
    }
    case kLine: {
      _this->_internal_mutable_line()->::ether::draw::Line::MergeFrom(
          from._internal_line());
      break;
    }
    case kArrow: {
      _this->_internal_mutable_arrow()->::ether::draw::Arrow::MergeFrom(
          from._internal_arrow());
      break;
    }
    case kPolygon: {
      _this->_internal_mutable_polygon()->::ether::draw::Polygon::MergeFrom(
          from._internal_polygon());
      break;
    }
    case kRect: {
      _this->_internal_mutable_rect()->::ether::draw::Rect::MergeFrom(
          from._internal_rect());
      break;
    }
    case kCircle: {
      _this->_internal_mutable_circle()->::ether::draw::Circle::MergeFrom(
          from._internal_circle());
      break;
    }
    case OBJECT_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void DrawObject::CopyFrom(const DrawObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ether.draw.DrawObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DrawObject::IsInitialized() const {
  return true;
}

void DrawObject::InternalSwap(DrawObject* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_.object_, other->_impl_.object_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata DrawObject::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ether_2fdraw_2eproto_getter, &descriptor_table_ether_2fdraw_2eproto_once,
      file_level_metadata_ether_2fdraw_2eproto[3]);
}

// ===================================================================

class RobotYel::_Internal {
 public:
};

RobotYel::RobotYel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ether.draw.RobotYel)
}
RobotYel::RobotYel(const RobotYel& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RobotYel* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.rotation_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rotation_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.rotation_));
  // @@protoc_insertion_point(copy_constructor:ether.draw.RobotYel)
}

inline void RobotYel::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.rotation_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RobotYel::~RobotYel() {
  // @@protoc_insertion_point(destructor:ether.draw.RobotYel)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RobotYel::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RobotYel::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RobotYel::Clear() {
// @@protoc_insertion_point(message_clear_start:ether.draw.RobotYel)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.rotation_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.rotation_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RobotYel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float rotation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.rotation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RobotYel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ether.draw.RobotYel)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // float rotation = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotation = this->_internal_rotation();
  uint32_t raw_rotation;
  memcpy(&raw_rotation, &tmp_rotation, sizeof(tmp_rotation));
  if (raw_rotation != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_rotation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ether.draw.RobotYel)
  return target;
}

size_t RobotYel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ether.draw.RobotYel)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  // float rotation = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotation = this->_internal_rotation();
  uint32_t raw_rotation;
  memcpy(&raw_rotation, &tmp_rotation, sizeof(tmp_rotation));
  if (raw_rotation != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RobotYel::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RobotYel::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RobotYel::GetClassData() const { return &_class_data_; }


void RobotYel::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RobotYel*>(&to_msg);
  auto& from = static_cast<const RobotYel&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ether.draw.RobotYel)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotation = from._internal_rotation();
  uint32_t raw_rotation;
  memcpy(&raw_rotation, &tmp_rotation, sizeof(tmp_rotation));
  if (raw_rotation != 0) {
    _this->_internal_set_rotation(from._internal_rotation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RobotYel::CopyFrom(const RobotYel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ether.draw.RobotYel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotYel::IsInitialized() const {
  return true;
}

void RobotYel::InternalSwap(RobotYel* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RobotYel, _impl_.rotation_)
      + sizeof(RobotYel::_impl_.rotation_)
      - PROTOBUF_FIELD_OFFSET(RobotYel, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RobotYel::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ether_2fdraw_2eproto_getter, &descriptor_table_ether_2fdraw_2eproto_once,
      file_level_metadata_ether_2fdraw_2eproto[4]);
}

// ===================================================================

class RobotBlu::_Internal {
 public:
};

RobotBlu::RobotBlu(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ether.draw.RobotBlu)
}
RobotBlu::RobotBlu(const RobotBlu& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  RobotBlu* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.rotation_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.rotation_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.rotation_));
  // @@protoc_insertion_point(copy_constructor:ether.draw.RobotBlu)
}

inline void RobotBlu::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.rotation_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

RobotBlu::~RobotBlu() {
  // @@protoc_insertion_point(destructor:ether.draw.RobotBlu)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void RobotBlu::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void RobotBlu::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void RobotBlu::Clear() {
// @@protoc_insertion_point(message_clear_start:ether.draw.RobotBlu)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.rotation_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.rotation_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* RobotBlu::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float rotation = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.rotation_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* RobotBlu::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ether.draw.RobotBlu)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // float rotation = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotation = this->_internal_rotation();
  uint32_t raw_rotation;
  memcpy(&raw_rotation, &tmp_rotation, sizeof(tmp_rotation));
  if (raw_rotation != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_rotation(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ether.draw.RobotBlu)
  return target;
}

size_t RobotBlu::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ether.draw.RobotBlu)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  // float rotation = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotation = this->_internal_rotation();
  uint32_t raw_rotation;
  memcpy(&raw_rotation, &tmp_rotation, sizeof(tmp_rotation));
  if (raw_rotation != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData RobotBlu::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    RobotBlu::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*RobotBlu::GetClassData() const { return &_class_data_; }


void RobotBlu::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<RobotBlu*>(&to_msg);
  auto& from = static_cast<const RobotBlu&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ether.draw.RobotBlu)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_rotation = from._internal_rotation();
  uint32_t raw_rotation;
  memcpy(&raw_rotation, &tmp_rotation, sizeof(tmp_rotation));
  if (raw_rotation != 0) {
    _this->_internal_set_rotation(from._internal_rotation());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void RobotBlu::CopyFrom(const RobotBlu& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ether.draw.RobotBlu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RobotBlu::IsInitialized() const {
  return true;
}

void RobotBlu::InternalSwap(RobotBlu* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(RobotBlu, _impl_.rotation_)
      + sizeof(RobotBlu::_impl_.rotation_)
      - PROTOBUF_FIELD_OFFSET(RobotBlu, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata RobotBlu::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ether_2fdraw_2eproto_getter, &descriptor_table_ether_2fdraw_2eproto_once,
      file_level_metadata_ether_2fdraw_2eproto[5]);
}

// ===================================================================

class Ball::_Internal {
 public:
};

Ball::Ball(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ether.draw.Ball)
}
Ball::Ball(const Ball& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Ball* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.y_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  // @@protoc_insertion_point(copy_constructor:ether.draw.Ball)
}

inline void Ball::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

Ball::~Ball() {
  // @@protoc_insertion_point(destructor:ether.draw.Ball)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Ball::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void Ball::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Ball::Clear() {
// @@protoc_insertion_point(message_clear_start:ether.draw.Ball)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.y_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.y_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Ball::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Ball::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ether.draw.Ball)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ether.draw.Ball)
  return target;
}

size_t Ball::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ether.draw.Ball)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Ball::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Ball::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Ball::GetClassData() const { return &_class_data_; }


void Ball::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Ball*>(&to_msg);
  auto& from = static_cast<const Ball&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ether.draw.Ball)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Ball::CopyFrom(const Ball& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ether.draw.Ball)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ball::IsInitialized() const {
  return true;
}

void Ball::InternalSwap(Ball* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Ball, _impl_.y_)
      + sizeof(Ball::_impl_.y_)
      - PROTOBUF_FIELD_OFFSET(Ball, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Ball::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ether_2fdraw_2eproto_getter, &descriptor_table_ether_2fdraw_2eproto_once,
      file_level_metadata_ether_2fdraw_2eproto[6]);
}

// ===================================================================

class Line::_Internal {
 public:
};

Line::Line(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ether.draw.Line)
}
Line::Line(const Line& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Line* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_list_){from._impl_.x_list_}
    , decltype(_impl_.y_list_){from._impl_.y_list_}
    , decltype(_impl_.color_){}
    , decltype(_impl_.width_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.width_ = from._impl_.width_;
  // @@protoc_insertion_point(copy_constructor:ether.draw.Line)
}

inline void Line::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_list_){arena}
    , decltype(_impl_.y_list_){arena}
    , decltype(_impl_.color_){}
    , decltype(_impl_.width_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Line::~Line() {
  // @@protoc_insertion_point(destructor:ether.draw.Line)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Line::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.x_list_.~RepeatedField();
  _impl_.y_list_.~RepeatedField();
  _impl_.color_.Destroy();
}

void Line::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Line::Clear() {
// @@protoc_insertion_point(message_clear_start:ether.draw.Line)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.x_list_.Clear();
  _impl_.y_list_.Clear();
  _impl_.color_.ClearToEmpty();
  _impl_.width_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Line::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float x_list = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_x_list(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 13) {
          _internal_add_x_list(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated float y_list = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_y_list(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 21) {
          _internal_add_y_list(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // string color = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "ether.draw.Line.color"));
        } else
          goto handle_unusual;
        continue;
      // float width = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Line::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ether.draw.Line)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float x_list = 1;
  if (this->_internal_x_list_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_x_list(), target);
  }

  // repeated float y_list = 2;
  if (this->_internal_y_list_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_y_list(), target);
  }

  // string color = 3;
  if (!this->_internal_color().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_color().data(), static_cast<int>(this->_internal_color().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ether.draw.Line.color");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_color(), target);
  }

  // float width = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_width = this->_internal_width();
  uint32_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_width(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ether.draw.Line)
  return target;
}

size_t Line::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ether.draw.Line)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float x_list = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_x_list_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float y_list = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_y_list_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // string color = 3;
  if (!this->_internal_color().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_color());
  }

  // float width = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_width = this->_internal_width();
  uint32_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Line::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Line::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Line::GetClassData() const { return &_class_data_; }


void Line::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Line*>(&to_msg);
  auto& from = static_cast<const Line&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ether.draw.Line)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.x_list_.MergeFrom(from._impl_.x_list_);
  _this->_impl_.y_list_.MergeFrom(from._impl_.y_list_);
  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_width = from._internal_width();
  uint32_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    _this->_internal_set_width(from._internal_width());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Line::CopyFrom(const Line& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ether.draw.Line)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Line::IsInitialized() const {
  return true;
}

void Line::InternalSwap(Line* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.x_list_.InternalSwap(&other->_impl_.x_list_);
  _impl_.y_list_.InternalSwap(&other->_impl_.y_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.color_, lhs_arena,
      &other->_impl_.color_, rhs_arena
  );
  swap(_impl_.width_, other->_impl_.width_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Line::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ether_2fdraw_2eproto_getter, &descriptor_table_ether_2fdraw_2eproto_once,
      file_level_metadata_ether_2fdraw_2eproto[7]);
}

// ===================================================================

class Arrow::_Internal {
 public:
};

Arrow::Arrow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ether.draw.Arrow)
}
Arrow::Arrow(const Arrow& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Arrow* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.color_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.dx_){}
    , decltype(_impl_.dy_){}
    , decltype(_impl_.width_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.width_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.width_));
  // @@protoc_insertion_point(copy_constructor:ether.draw.Arrow)
}

inline void Arrow::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.color_){}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.dx_){0}
    , decltype(_impl_.dy_){0}
    , decltype(_impl_.width_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Arrow::~Arrow() {
  // @@protoc_insertion_point(destructor:ether.draw.Arrow)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Arrow::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.color_.Destroy();
}

void Arrow::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Arrow::Clear() {
// @@protoc_insertion_point(message_clear_start:ether.draw.Arrow)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.color_.ClearToEmpty();
  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.width_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.width_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Arrow::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float dx = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.dx_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float dy = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.dy_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // string color = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "ether.draw.Arrow.color"));
        } else
          goto handle_unusual;
        continue;
      // float width = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Arrow::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ether.draw.Arrow)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // float dx = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_dx = this->_internal_dx();
  uint32_t raw_dx;
  memcpy(&raw_dx, &tmp_dx, sizeof(tmp_dx));
  if (raw_dx != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_dx(), target);
  }

  // float dy = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_dy = this->_internal_dy();
  uint32_t raw_dy;
  memcpy(&raw_dy, &tmp_dy, sizeof(tmp_dy));
  if (raw_dy != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_dy(), target);
  }

  // string color = 5;
  if (!this->_internal_color().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_color().data(), static_cast<int>(this->_internal_color().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ether.draw.Arrow.color");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_color(), target);
  }

  // float width = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_width = this->_internal_width();
  uint32_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_width(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ether.draw.Arrow)
  return target;
}

size_t Arrow::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ether.draw.Arrow)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string color = 5;
  if (!this->_internal_color().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_color());
  }

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  // float dx = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_dx = this->_internal_dx();
  uint32_t raw_dx;
  memcpy(&raw_dx, &tmp_dx, sizeof(tmp_dx));
  if (raw_dx != 0) {
    total_size += 1 + 4;
  }

  // float dy = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_dy = this->_internal_dy();
  uint32_t raw_dy;
  memcpy(&raw_dy, &tmp_dy, sizeof(tmp_dy));
  if (raw_dy != 0) {
    total_size += 1 + 4;
  }

  // float width = 6;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_width = this->_internal_width();
  uint32_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Arrow::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Arrow::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Arrow::GetClassData() const { return &_class_data_; }


void Arrow::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Arrow*>(&to_msg);
  auto& from = static_cast<const Arrow&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ether.draw.Arrow)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_dx = from._internal_dx();
  uint32_t raw_dx;
  memcpy(&raw_dx, &tmp_dx, sizeof(tmp_dx));
  if (raw_dx != 0) {
    _this->_internal_set_dx(from._internal_dx());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_dy = from._internal_dy();
  uint32_t raw_dy;
  memcpy(&raw_dy, &tmp_dy, sizeof(tmp_dy));
  if (raw_dy != 0) {
    _this->_internal_set_dy(from._internal_dy());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_width = from._internal_width();
  uint32_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    _this->_internal_set_width(from._internal_width());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Arrow::CopyFrom(const Arrow& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ether.draw.Arrow)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Arrow::IsInitialized() const {
  return true;
}

void Arrow::InternalSwap(Arrow* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.color_, lhs_arena,
      &other->_impl_.color_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Arrow, _impl_.width_)
      + sizeof(Arrow::_impl_.width_)
      - PROTOBUF_FIELD_OFFSET(Arrow, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Arrow::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ether_2fdraw_2eproto_getter, &descriptor_table_ether_2fdraw_2eproto_once,
      file_level_metadata_ether_2fdraw_2eproto[8]);
}

// ===================================================================

class Polygon::_Internal {
 public:
};

Polygon::Polygon(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ether.draw.Polygon)
}
Polygon::Polygon(const Polygon& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Polygon* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.x_list_){from._impl_.x_list_}
    , decltype(_impl_.y_list_){from._impl_.y_list_}
    , decltype(_impl_.color_){}
    , decltype(_impl_.width_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.width_ = from._impl_.width_;
  // @@protoc_insertion_point(copy_constructor:ether.draw.Polygon)
}

inline void Polygon::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.x_list_){arena}
    , decltype(_impl_.y_list_){arena}
    , decltype(_impl_.color_){}
    , decltype(_impl_.width_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Polygon::~Polygon() {
  // @@protoc_insertion_point(destructor:ether.draw.Polygon)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Polygon::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.x_list_.~RepeatedField();
  _impl_.y_list_.~RepeatedField();
  _impl_.color_.Destroy();
}

void Polygon::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Polygon::Clear() {
// @@protoc_insertion_point(message_clear_start:ether.draw.Polygon)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.x_list_.Clear();
  _impl_.y_list_.Clear();
  _impl_.color_.ClearToEmpty();
  _impl_.width_ = 0;
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Polygon::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float x_list = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_x_list(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 13) {
          _internal_add_x_list(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated float y_list = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_y_list(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 21) {
          _internal_add_y_list(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // string color = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "ether.draw.Polygon.color"));
        } else
          goto handle_unusual;
        continue;
      // float width = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Polygon::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ether.draw.Polygon)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float x_list = 1;
  if (this->_internal_x_list_size() > 0) {
    target = stream->WriteFixedPacked(1, _internal_x_list(), target);
  }

  // repeated float y_list = 2;
  if (this->_internal_y_list_size() > 0) {
    target = stream->WriteFixedPacked(2, _internal_y_list(), target);
  }

  // string color = 3;
  if (!this->_internal_color().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_color().data(), static_cast<int>(this->_internal_color().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ether.draw.Polygon.color");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_color(), target);
  }

  // float width = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_width = this->_internal_width();
  uint32_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_width(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ether.draw.Polygon)
  return target;
}

size_t Polygon::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ether.draw.Polygon)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float x_list = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_x_list_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // repeated float y_list = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_y_list_size());
    size_t data_size = 4UL * count;
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    total_size += data_size;
  }

  // string color = 3;
  if (!this->_internal_color().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_color());
  }

  // float width = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_width = this->_internal_width();
  uint32_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Polygon::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Polygon::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Polygon::GetClassData() const { return &_class_data_; }


void Polygon::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Polygon*>(&to_msg);
  auto& from = static_cast<const Polygon&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ether.draw.Polygon)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.x_list_.MergeFrom(from._impl_.x_list_);
  _this->_impl_.y_list_.MergeFrom(from._impl_.y_list_);
  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_width = from._internal_width();
  uint32_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    _this->_internal_set_width(from._internal_width());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Polygon::CopyFrom(const Polygon& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ether.draw.Polygon)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Polygon::IsInitialized() const {
  return true;
}

void Polygon::InternalSwap(Polygon* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.x_list_.InternalSwap(&other->_impl_.x_list_);
  _impl_.y_list_.InternalSwap(&other->_impl_.y_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.color_, lhs_arena,
      &other->_impl_.color_, rhs_arena
  );
  swap(_impl_.width_, other->_impl_.width_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Polygon::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ether_2fdraw_2eproto_getter, &descriptor_table_ether_2fdraw_2eproto_once,
      file_level_metadata_ether_2fdraw_2eproto[9]);
}

// ===================================================================

class Rect::_Internal {
 public:
};

Rect::Rect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ether.draw.Rect)
}
Rect::Rect(const Rect& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Rect* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.color_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.width_){}
    , decltype(_impl_.height_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.height_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.height_));
  // @@protoc_insertion_point(copy_constructor:ether.draw.Rect)
}

inline void Rect::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.color_){}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.width_){0}
    , decltype(_impl_.height_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Rect::~Rect() {
  // @@protoc_insertion_point(destructor:ether.draw.Rect)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Rect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.color_.Destroy();
}

void Rect::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Rect::Clear() {
// @@protoc_insertion_point(message_clear_start:ether.draw.Rect)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.color_.ClearToEmpty();
  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.height_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.height_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Rect::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float width = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float height = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // string color = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "ether.draw.Rect.color"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Rect::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ether.draw.Rect)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // float width = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_width = this->_internal_width();
  uint32_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_width(), target);
  }

  // float height = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_height = this->_internal_height();
  uint32_t raw_height;
  memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
  if (raw_height != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_height(), target);
  }

  // string color = 5;
  if (!this->_internal_color().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_color().data(), static_cast<int>(this->_internal_color().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ether.draw.Rect.color");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_color(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ether.draw.Rect)
  return target;
}

size_t Rect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ether.draw.Rect)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string color = 5;
  if (!this->_internal_color().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_color());
  }

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  // float width = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_width = this->_internal_width();
  uint32_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    total_size += 1 + 4;
  }

  // float height = 4;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_height = this->_internal_height();
  uint32_t raw_height;
  memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
  if (raw_height != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Rect::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Rect::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Rect::GetClassData() const { return &_class_data_; }


void Rect::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Rect*>(&to_msg);
  auto& from = static_cast<const Rect&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ether.draw.Rect)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_width = from._internal_width();
  uint32_t raw_width;
  memcpy(&raw_width, &tmp_width, sizeof(tmp_width));
  if (raw_width != 0) {
    _this->_internal_set_width(from._internal_width());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_height = from._internal_height();
  uint32_t raw_height;
  memcpy(&raw_height, &tmp_height, sizeof(tmp_height));
  if (raw_height != 0) {
    _this->_internal_set_height(from._internal_height());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Rect::CopyFrom(const Rect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ether.draw.Rect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Rect::IsInitialized() const {
  return true;
}

void Rect::InternalSwap(Rect* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.color_, lhs_arena,
      &other->_impl_.color_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Rect, _impl_.height_)
      + sizeof(Rect::_impl_.height_)
      - PROTOBUF_FIELD_OFFSET(Rect, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Rect::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ether_2fdraw_2eproto_getter, &descriptor_table_ether_2fdraw_2eproto_once,
      file_level_metadata_ether_2fdraw_2eproto[10]);
}

// ===================================================================

class Circle::_Internal {
 public:
};

Circle::Circle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ether.draw.Circle)
}
Circle::Circle(const Circle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  Circle* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.color_){}
    , decltype(_impl_.x_){}
    , decltype(_impl_.y_){}
    , decltype(_impl_.radius_){}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_color().empty()) {
    _this->_impl_.color_.Set(from._internal_color(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.x_, &from._impl_.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.radius_) -
    reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.radius_));
  // @@protoc_insertion_point(copy_constructor:ether.draw.Circle)
}

inline void Circle::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.color_){}
    , decltype(_impl_.x_){0}
    , decltype(_impl_.y_){0}
    , decltype(_impl_.radius_){0}
    , /*decltype(_impl_._cached_size_)*/{}
  };
  _impl_.color_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.color_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

Circle::~Circle() {
  // @@protoc_insertion_point(destructor:ether.draw.Circle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void Circle::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.color_.Destroy();
}

void Circle::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void Circle::Clear() {
// @@protoc_insertion_point(message_clear_start:ether.draw.Circle)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.color_.ClearToEmpty();
  ::memset(&_impl_.x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.radius_) -
      reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.radius_));
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Circle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // float x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // float radius = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // string color = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_color();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, "ether.draw.Circle.color"));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* Circle::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ether.draw.Circle)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_x(), target);
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_y(), target);
  }

  // float radius = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_radius = this->_internal_radius();
  uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_radius(), target);
  }

  // string color = 4;
  if (!this->_internal_color().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_color().data(), static_cast<int>(this->_internal_color().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "ether.draw.Circle.color");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_color(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ether.draw.Circle)
  return target;
}

size_t Circle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ether.draw.Circle)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string color = 4;
  if (!this->_internal_color().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_color());
  }

  // float x = 1;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = this->_internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    total_size += 1 + 4;
  }

  // float y = 2;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = this->_internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    total_size += 1 + 4;
  }

  // float radius = 3;
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_radius = this->_internal_radius();
  uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData Circle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    Circle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*Circle::GetClassData() const { return &_class_data_; }


void Circle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<Circle*>(&to_msg);
  auto& from = static_cast<const Circle&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ether.draw.Circle)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_color().empty()) {
    _this->_internal_set_color(from._internal_color());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_x = from._internal_x();
  uint32_t raw_x;
  memcpy(&raw_x, &tmp_x, sizeof(tmp_x));
  if (raw_x != 0) {
    _this->_internal_set_x(from._internal_x());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_y = from._internal_y();
  uint32_t raw_y;
  memcpy(&raw_y, &tmp_y, sizeof(tmp_y));
  if (raw_y != 0) {
    _this->_internal_set_y(from._internal_y());
  }
  static_assert(sizeof(uint32_t) == sizeof(float), "Code assumes uint32_t and float are the same size.");
  float tmp_radius = from._internal_radius();
  uint32_t raw_radius;
  memcpy(&raw_radius, &tmp_radius, sizeof(tmp_radius));
  if (raw_radius != 0) {
    _this->_internal_set_radius(from._internal_radius());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void Circle::CopyFrom(const Circle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ether.draw.Circle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Circle::IsInitialized() const {
  return true;
}

void Circle::InternalSwap(Circle* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.color_, lhs_arena,
      &other->_impl_.color_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Circle, _impl_.radius_)
      + sizeof(Circle::_impl_.radius_)
      - PROTOBUF_FIELD_OFFSET(Circle, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Circle::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ether_2fdraw_2eproto_getter, &descriptor_table_ether_2fdraw_2eproto_once,
      file_level_metadata_ether_2fdraw_2eproto[11]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace draw
}  // namespace ether
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::ether::draw::DrawCommand_LayersEntry_DoNotUse*
Arena::CreateMaybeMessage< ::ether::draw::DrawCommand_LayersEntry_DoNotUse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ether::draw::DrawCommand_LayersEntry_DoNotUse >(arena);
}
template<> PROTOBUF_NOINLINE ::ether::draw::DrawCommand*
Arena::CreateMaybeMessage< ::ether::draw::DrawCommand >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ether::draw::DrawCommand >(arena);
}
template<> PROTOBUF_NOINLINE ::ether::draw::Layer*
Arena::CreateMaybeMessage< ::ether::draw::Layer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ether::draw::Layer >(arena);
}
template<> PROTOBUF_NOINLINE ::ether::draw::DrawObject*
Arena::CreateMaybeMessage< ::ether::draw::DrawObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ether::draw::DrawObject >(arena);
}
template<> PROTOBUF_NOINLINE ::ether::draw::RobotYel*
Arena::CreateMaybeMessage< ::ether::draw::RobotYel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ether::draw::RobotYel >(arena);
}
template<> PROTOBUF_NOINLINE ::ether::draw::RobotBlu*
Arena::CreateMaybeMessage< ::ether::draw::RobotBlu >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ether::draw::RobotBlu >(arena);
}
template<> PROTOBUF_NOINLINE ::ether::draw::Ball*
Arena::CreateMaybeMessage< ::ether::draw::Ball >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ether::draw::Ball >(arena);
}
template<> PROTOBUF_NOINLINE ::ether::draw::Line*
Arena::CreateMaybeMessage< ::ether::draw::Line >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ether::draw::Line >(arena);
}
template<> PROTOBUF_NOINLINE ::ether::draw::Arrow*
Arena::CreateMaybeMessage< ::ether::draw::Arrow >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ether::draw::Arrow >(arena);
}
template<> PROTOBUF_NOINLINE ::ether::draw::Polygon*
Arena::CreateMaybeMessage< ::ether::draw::Polygon >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ether::draw::Polygon >(arena);
}
template<> PROTOBUF_NOINLINE ::ether::draw::Rect*
Arena::CreateMaybeMessage< ::ether::draw::Rect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ether::draw::Rect >(arena);
}
template<> PROTOBUF_NOINLINE ::ether::draw::Circle*
Arena::CreateMaybeMessage< ::ether::draw::Circle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ether::draw::Circle >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
